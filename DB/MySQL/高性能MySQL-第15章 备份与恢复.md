# 第15章 备份与恢复

名词定义：

还原：还原意味着从备份文件中获取数据，可以加载这些文件到MySQL里，也可以将这些文件放置到MySQL期望的路径中。

恢复：恢复一般意味着当某些异常发生后对一个系统或其他部分的拯救。包括从备份中还原数据，以及使服务器完全恢复功能的所有必要步骤，例如重启MySQL，改变配置和预热服务器的缓存等。

## 15.1 为什么要备份

下面是备份非常重要的几个理由：

1. 灾难恢复
2. 人们改变想法
3. 审计
4. 测试

## 15.2 定义恢复需求

规划备份和恢复策略时，有两个重要的需求可以帮助思考：恢复点目标（PRO）和恢复时间目标（RTO）。它们定义了可以容忍丢失多少数据，以及需要等待多久将数据恢复。在定义RPO和RTO时，先尝试回答下面几类问题：

1. 在不导致严重后果的情况下，可以容忍丢失多少数据？需要故障恢复，还是可以接受自从上次日常备份后所有的工作全部丢失？是否有法律法规的要求？

2. 恢复需要在多长时间内完成？那种类型的宕机是可以接收的？哪种影响（例如，部分服务不可用）是应用和用户可以接受的？当那些场景发生时，又该如何持续服务？

3. 需要恢复什么？常见的需求是恢复整个服务器，单个数据库，单个表，或仅仅是特定的事务或语句。

## 15.3 设计MySQL备份方案

在深入所有选项细节之前，先来看一下我们的建议：

1. 在生产实践中，对于大数据库来说，物理备份是必需的：逻辑备份太慢并受到资源限，从逻辑备份中恢复需要很长时间。基于快照的备份，例如PerconaXtraBackup和MySQL Enterprise Backup是最好的选择。对于较小的数据库，逻辑备份可以很好地胜任。
2. 保留多个备份集
3. 定期从逻辑备份（或物理备份）中抽取数据进行恢复测试
4. 保存二进制日志以用于基于故障时间点的恢复。expire_logs_days参数应该设置的足够长，至少可以从最近两次物理备份中做基于时间点的恢复，这样就可以在保持主库运行且不应用任何二进制日志的情况下创建一个备库。备库二进制日志与国企设置无关，二进制日志备份需要保存足够长的时间，以便能从最近的逻辑备份进行恢复。
5. 完全不借助备份工具本身来监控备份和备份的过程。需要另外验证备份是否正常。
6. 通过演练整个恢复过程来测试备份和恢复。测算恢复所需要的资源（CPU、磁盘空间、实际时间，以及网络带宽等）。
7. 对安全性要仔细考虑、如果有人能接触生产服务器，他是否也能访问备份服务器？反过来呢？

### 15.3.1 在线备份还是离线备份

在规划备份时，有一些与性能相关的因素需要考虑

- 锁时间

  需要持有锁多长时间，例如在备份期间持有的全局FlUSH TABLES WITH READ LOCK?

- 备份时间

  复制备份到目的地需要多久？

- 备份负载

  在复制备份到目的地时对服务器性能的影响有多少？

- 恢复时间

  把备份镜像从存储位置复制到MySQL服务器，重放二进制日志等，需要多久？

最大的权衡是备份时间与备份负载。可以牺牲其一以增强另外一个。例如，可以提高备份的优先级，代价是降低服务器性能。

### 15.3.2 逻辑备份还是物理备份

有两种主要的方法来备份MySQL数据：逻辑备份（也叫“导出”）和直接复制原始文件和物理备份。逻辑备份将数据包含在一种MySQL能够解析的格式中，要么是SQL,要么是以某个符号分隔的文本。原始文件是指存储在硬盘上的文件。

#### 逻辑备份

优点：

1. 逻辑备份可以用编辑器查看和操作的普通文件。
2. 恢复非常简单。可以通过管道把它们输入到mysql，或者使用mysqlimport。
3. 可以通过网络来备份和恢复——就是说，可以在与MySQL主机不同的另外一台机器上操作。
4. 可以在类似AmazonRDS这样不能访问底层文件系统的系统中使用。
5. 非常灵活，因为mysqldump——大部分人喜欢的工具——可以接受许多选项，例如可以用WHERE字句来限制需要备份那些行。
6. 与存储引擎无关。
7. 有助于避免数据损坏。如果磁盘驱动器有故障而要复制原始文件时，你将会得到一个错误并且/或生成一个部分损坏的备份。如果MySQL在内存中的数据还没有损坏，当不能得到一个正常的原始文件复制时，有时可以得到一个可以信赖的逻辑备份。

缺点：

1. 必须由数据库服务器完成生成逻辑备份的工作，因此要使用更多的CPU周期。
2. 逻辑备份在某些场景下比数据库文件本身更大。ASCII形式的数据不总是和存储引擎存储数据一样高效。例如，一个整形需要4字节来存储，但是用ASCII写入时，可能需要12个字符。当然也可以压缩文件以得到一个更小的备份文件，但这样会使用更多的CPU资源。（如果索引比较多，逻辑备份一般比物理备份小。）
3. 无法保证导出后再还原出来的一定是同样的数据。浮点表示的问题、软件Bug等都会导致问题，尽管比较少见。
4. 从逻辑备份中还原需要Mysql加载和解释语句。转换为存储格式，并重建索引，所有这一切会很慢。

最大的缺点是从Mysql中导出数据和通过SQL语句将其加载回去的开销。如果使用逻辑备份，测试恢复需要的时间将非常重要。

#### 物理备份

优点：

1. 基于文件的物理备份，只需要将需要的文件复制到其他地方即可完成备份。不需要其他额外的工作来生成原始文件。
2. 物理备份的恢复可能就更简单了，这取决于存储引擎。对于MyISAM，只需要简单地复制文件到目的地即可。对于InnoDB则需要停止数据库服务，可能还要采取其他一些步骤。
3. InnoDB和MyISAM的物理备份非常容易跨平台、操作系统和MySQL版本。（逻辑导出亦如此。这里特别之处这一点是为了消除大家的担心。）
4. 从物理备份中恢复会更快，因为MySQL服务器不需要执行任何SQL或构建索引。如果有很大的InnoDB表，无法完全缓存到内存中，则物理备份的恢复要快非常多——至少要快一个数量级。事实上，逻辑备份最可怕的地方就是不确定的还原时间。

缺点：

1. InnoDB的原始文件通常比相应的逻辑备份要大得多。InnoDB的表空间往往包含很多未使用的空间。还有很多空间被用来做存储数据以外的用途（插入缓冲，回滚段等）。
2. 物理备份不总是可以跨平台、操作系统及MySQL版本。文件名大小写敏感和浮点格式是可能会遇到麻烦。很可能因浮点格式不同而不能移动文件到另一个系统（虽然主流处理器都使用IEEE浮点格式。）



建议混合使用物理和逻辑两种方式来做做备份：先使用物理复制，以此数据启动Mysql服务器实例并运行mysqlcheck。然后，周期性地使用mysqldump执行逻辑备份。这样做可以获得两种方法的优点不会使生产服务器在导出时有过度负担。如果能够方便地利用文件系统的快照，也可以生成一个快照，将该快照复制到另外一个服务器上并释放，然后测试原始文件，再执行逻辑备份。

### 15.3.3 备份是什么

恢复的需求决定需要备份什么。最简单的策略是只备份数据和表定义，但这是一个最低的要求。在生产环境中恢复数据库一般需要更多的工作。下面是Mysql备份需要考虑的几点。

- 非显著数据

  不要忘记那些容易被忽略的数据：例如，二进制日志和InnoDB事务日志。

- 代码

  现代的MySQL服务器可以存储许多代码，例如触发器和存储过程。

- 复制配置

  如果恢复一个设计复制关系的服务器，应该备份所有与复制相关的文件，例如二进制日志、中继日志、日志索引文件和。info文件。至少应该包含SHOW MASTER STATUS 和 SHOW SLAVE STATUS 的输出。

- 服务器配置

  假设要从一个实际的灾难中恢复，比如说，地震过后在一个新的数据中心中构建服务器，如果备份中包含服务器配置，你一定会喜出望外。

- 选定的操作系统文件

  对于服务器配置来说，备份中对生产服务器至关重要的任何外部配置，都十分重要。在UNIX服务器上，这可能包括cron任务、用户和组的配置、管理脚本，以及ssudo规则。



#### 增量备份和差异备份

差异备份：是对自从上次全备份后所有改变的部分而做的备份。

增量备份：是自从任意的类型的上次备份后所有修改做的备份。

增量和差异备份都是部分备份：它们一般不包含完整的数据集，因为某些数据几乎肯定没有改变。部分备份对减少服务器开销、备份时间及备份空间而言都很合适。尽管某些部分并不会真正减少服务器的开销。例如，Percona XtraBackup 和 MySQL EnterpriseBackup，任然会扫描服务器上的所有数据块，因而并不会借阅太多的开销，但他们确实会减少一定量的备份时间和大量用于压缩的CPU时间，当然也会减少磁盘空间的使用。

下面有一些建议：

- 使用Percona XtraBackup 和 MySQL EnterpriseBackup中的增量备份特性。
- 备份二进制日志。可以在每次备份后使用FLUSH LOGS来开始一个新的二进制日志，这样就只需要备份新的二进制日志。
- 不要备份没有改变的表。有些存储引擎，例如MyISAM，会记录每个表中最后修改时间。可以通过查看磁盘上的文件或运行SHOW TABLE STATUS来看这个时间。
- 不要备份没有改变的行。
- 某些数据根本不需要备份。有时候这样做影响会很大——例如，如果有一个从其他地方数据构建的数据仓库，从技术上将完全是冗余的，就可以仅备份构建仓库的数据，而不是数据仓库本身。
- 备份所有的数据，然后发送到一个有去重特性的目的地，例如ZFS文件管理程序。

### 15.3.4 存储引擎和一致性

#### 数据一致性

当备份时，应该考虑是否需要数据在指定时间点一致。

如果做在线备份，可能需要所有相关表的一致性备份。可能需要一次锁住所有需要备份的表进行备份。

InnoDB的多版本控制功能可以帮到我们。开始一个事务，转储一组相关的表，然后提交事务。只要在服务器上使用REPEATABLE READ事务隔离级别，并没有任何DDL，就一定会有完美的一致性，以及基于时间点的数据快照，切在备份过程中不会阻塞任何后续的工作。

#### 文件一致性

每个文件的内部一致性也非常重要——例如，一条大的UPDATE语句执行时备份反映不出文件的状态——并且所有要备份的文件相互间也应一致。如果没有内部一致的文件，还原时可能会感到惊讶（它们可能已经损坏）。如果是在不同的时间复制相关的文件，它们彼此可能也不一致。MyISAM的 .MYD 和 .MYI 文件就是个例子。InnoDB如果检测到不一致或损坏，会记录错误日志乃至让服务器崩溃。

// TODO 详见P604 

#### 复制

从备库中备份最大的好处是可以不干扰主库，避免在主库上增加额外负载。

当从备库备份时，应该保存所有关于复制进程的信息，例如备库相对于主库的位置。这对于很多情况都非常有用：克隆新的备库，重新应用二进制日志到主库上以获得指定时间点的恢复，将备库提升为主库等。如果停止备库，需要确保没有打开的临时表，因为他们可能导致不能重启备库。

## 15.4 管理和备份二进制日志

服务器的二进制日志是备份的最重要因素之一。他们对于基于时间点的恢复是必须的，并且通常比数据要小，所以更容易进行频繁的备份。如果有某个时间点的数据备份和所有那时以后的二进制日志，就可以重放自从上次全备一来的二进制日志并“前滚”所有变更。

#### 15.4.1 二进制日志格式

// TODO 详见P606

#### 15.4.2安全地清除老的二进制日志

需要决定日志的过期策略以防止磁盘被二进制日志写满。日志增长多大取决于负载和日志格式（基于行的日志会导致更大的日志记录）。我们建议如果可能，只要日志有用就尽可能保留。保留日志对于设置复制、分析服务器负载、审计和从上次全备按时间点进行恢复，都很有帮助。

一个常见的设置是使用`expire_log_days` 变量来告诉Mysql定期清理日志。`expire_log_days`设置在服务器启动或Mysql切换二进制日志时生效，因此，如果二进制日志从来没有增长和切换，服务器不会清楚老条目。此设置是通

过查看日志的修改时间而不是内容来决定哪个文件需要被清除。

## 15.5 备份数据

大多数时候，生成备份有好的也有差的方法——有时候显而易见的方法并不是好方法。一个有用的技巧是应该最大化利用网络、磁盘和CPU的能力以尽可能快的完成备份。这是一个需要不断去平衡的事情，必须通过实验以找到“最佳平衡点”。

### 15.5.1 生成逻辑备份

对于逻辑备份，首先要意识到的是他们并不是以同样方式创建的。实际上有两种类型的逻辑备份：SQL导出和符号分隔文件。

**SQL导出**

SQL导出时很多人所熟悉的，因为他们是mysqldump默认的方式。例如，默认选项导出一个小标将产生如下（有删减）输出。

导出文件包含表结构和数据，均以有效的SQL命令形式写出。

缺点：

- Schema和数据存储在一起
- 巨大的SQL语句
- 单个巨大的文件
- 逻辑备份的成本很高

**符号分隔文件备份**
可以使用SQL命令 SELECT INTO OUTFILE 以符号分隔文件格式创建数据的逻辑备份。（可以用mysqldump的--tab选项导出到符号分隔文件中。）符号分隔文件包含以ASCII战士的原始数据，没有SQL、注释和列名。

比起SQL导出文件，符号分隔文件要更紧凑且更容易于用命令行工具操作，这种方法最大的有点是备份和还原速度更快。可以和导出时使用一样的选项，用LOAD DATA INFILE方法加载数据到表中。

### 15.5.2 文件系统快照

支持快照的文件系统能够瞬间创建用来备份的内容一致的镜像。创建快照是减少必须持有锁的时间的一个简单方法；释放锁后，必须复制文件到备份中。

**LVM快照是如何工作的**

LVM使用写时复制的技术来创建快照——例如，对整个卷的某个瞬间的逻辑副本。这与数据库中的MVCC有点像，不同的是他只保留一个老的数据版本。

逻辑副本看起来好像包含了创建快照时卷中所有的数据，但实际上一开始快照是不包含数据的。相比复制数据到快照中，LVM只是简单地标记创建快照的时间点，然后对该快照请求读数据时，实际上是从原始卷中读取的。

**先决条件和配置**

创建一个快照的消耗几乎微不足道，但还是需要确保系统配置可以让你获取在备份瞬间的所有需要的文件的一致性副本。

- 所有的InnoDB文件（InnoDB的表空间文件和InnoDB的事务日志）必须是在单个逻辑卷（分区）。你需要绝对的时间点一致性，LVM不能为多于一个卷做某个时间点一致的快照。
- 如果需要备份表定义，Mysql数据目录必须在相同的逻辑卷中。如果使用另外一种方法来备份表的定义，例如只备份Schema到版本控制系统中，就不需要担心这个问题。
- 必须在卷组中有足够的空闲孔家来创建快照。需要多少取决于负载。当配置系统时，应该留一些未分配的空间以便后面做快照。

**用于在线备份的LVM快照**

首先使用一个全局的读锁。连接Mysql服务器并使用一个全局读锁将表刷到磁盘上，然后获取二进制日志的位置：

mysql > FLUSH TABLES WITH READ LOCK;SHOW MASTER STATUS;

记录SHOW MASTER STATUS的释出，确保到Mysql的连接处于打开状态，以使读锁不被释放。然后获取LVM的快照并立即释放该读锁，可以使用UNLOCK TABLES 或者直接关闭连接来释放锁。最后，加载快照并复制文件到备份位置。

**使用LVM快照无锁InnoDB备份**
无锁备份区别在于只锁MyISAM类型的系统表。

## 15.6 从备份中恢复

如何恢复数据取决于是怎么备份的。可能需要以下部分或全部步骤。

- 停止Mysql服务器。
- 记录服务器的配置和文件权限。
- 将数据从备份中移到Mysql数据目录。
- 改变配置。
- 改变文件权限。
- 以限制访问模式重启服务器，等待完成启动。
- 载入逻辑备份文件。
- 检查和重放二进制日志。
- 检测已经还原的数据。
- 以完全权限重启服务器。

### 15.6.1 恢复物理备份

恢复物理备份往往非常直接——换言之，没有太多的选项。这可能是好事，也可能是坏事，具体取决于恢复的需求。一般过程是简单地复制文件到正确位置。

如果用传统的InnoDB的步骤来还原，即所有表都存储在单个表空间，就必须关闭Mysql，复制或移动文件到正确位置上，然后重启。同样也需要InnoDB的事务日志文件与表空间文件匹配。如果文件不匹配——例如，替换了表空间文件但没有替换事务日志文件——InnoDB将会拒绝启动。

**还原物理备份后启动Mysql**

首先，最重要切最容易忘记的事情，是在启动Mysql服务器之前检查服务器的配置，确保恢复的文件有正确的归属和权限。这些属性必须完全正确，否则Mysql可能无法启动。这些属性因系统的不同而不同，因此要仔细检查是否和之前做的记录温和。一般都需要mysql用户和组拥有这些文件和目录，并且只有这个用户和组拥有可读/写权限。

建议观察Mysql启动时的错误日志。

### 15.6.2 还原逻辑备份

在加载导出文件之前，需要考虑文件有多大？需要多久加载玩？以及在启动之前还需要做什么事情，例如通知用户或禁掉部分应用。禁掉二进制日志也是个好主意，除非需要将还原操作复制到备库。

**加载SQL文件**

如果有一个SQL导出文件，它将包含可执行的SQL。需要做的就是运行这个文件。

**加载符号分隔文件**
如果是通过SELECT INTO OUTFILE导出的符号分隔文件，可以使用LOAD DATA INFILE通过相同的参数来加载。也可以使用mysqlimport，这是LOAD DATA INFILE的一个包装。这种方式一来命名约定决定从哪里加载一个文件数据。

### 15.6.3 基于时间点的恢复

对于Mysql做基于时间点的恢复常见的方法是还原最近一次全备份，然后从哪个时间点开始重放二进制日志（有时叫“前滚恢复”）。只要有二进制日志，就可以恢复到任何希望的时间点。甚至可以不太费力气恢复单个数据库。

### 15.6.4 更高级的恢复技术

- 用于快速恢复的延时复制
- 使用日志服务器进行恢复

### 15.6.5 InnoDB崩溃恢复

InnoDB在每次启动时都会检测数据和日志文件，以确定是否需要执行恢复过程。而且，InnoDB的恢复过程与我们在本章之前谈论的不是一回事。他并不是恢复备份的数据；而是根据日志文件将事务应用到数据文件，将未提交的变更从数据文件中回滚。

大部分情况下InnoDB可以很好地解决问题。除非Mysql有Bug或硬件有问题，否则不需要做任何非常规的事情。

**InnoDB损坏的原因**

InnoDB依赖于无缓存的I/O调用和fsync()调用，知道数据完全的写入到物理介质上才会返回。如果硬件不能保证写入的持久化，InnoDB也就不能保证数据的持久，崩溃就有可能导致数据损坏。

**如何恢复损坏的InnoDB数据**

InnoDB损坏有三种主要类型，他们对和数据恢复有着不同程度的要求。

- 二级索引损坏

  一般可以用OPTIMIZE TABLE来修复损坏的二级索引

- 聚簇索引损坏

  也许只能使用 `innodb_force_recovery` 选项来导出表。有时导出过程会让InnoDB崩溃；如果出现这样的情况，或许需要跳过导致崩溃的损坏页以导出其他的记录。聚簇索引的损坏比二级索引要更难修复，因为它会影响数据行本身，但在多数场合下任然只需要修复受影响的表。

- 损坏系统结构

- 系统结构包括InnoDB事务日志、表空间和撤销日志（undo log）区域和数据字典。这种损坏可能需要做整个数据库的导出和还原，因为InnoDB内部绝大部分的工作都会受到影响
