# 第14章 应用层优化

## 14.1 常见问题

- 什么东西在消耗系统中每台主机的CPU、磁盘、网络，以及内存资源？这些值是否合理？
- 应用真的需要所有获取到的数据吗？
- 应用在处理本应由数据库处理的事情吗，或者反过来？
- 应用执行了太多查询？
- 应用执行的查询太少了？
- 应用创建了没必要的Mysql连接吗？
- 应用对一个Mysql实例创建连接的次数太多了吗？
- 应用做了太多“垃圾”查询？
- 应用使用了连接池吗？
- 应用是否使用长连接？
- 应用是否在不使用的时候还保持连接打开？

## 14.2 Web服务器问题

最常见的问题是保持它的进程的存活时间过长，或者在各种不同的用途下混合使用，而不是分别对不同类型的工作进行优化。

- 使用缓存代理服务器，比如Squid或者Varnish，防止所有的请求都到达Web服务器。
- 对动态和静态资源都设置过期策略。

### 14.2.1 寻找最优并发度

每个Web服务器都有一个最佳并发度——就是说，让进程处理请求尽可能快，并且不超过系统负载的最优的并发连接数。

对于CPU密集型工作负载，最佳并发度等于CPU数量（或者CPU核数）。然而，进程并不总是处于可运行状态的，因为会有一些阻塞式请求，例如I/O、数据库查询，以及网络请求。因此，最佳并发度通常会比CPU数量高一些。

 ## 14.3 缓存

缓存对于高负载应用来说是至关重要的。一个典型的Web应用程序会提供大量的内容，直接生成这些内容的成本比采用缓存要高很多（包含检查和缓存超时的开销），所以采用缓存通常可以获取数量级的性能提升。诀窍是找到正确的粒度和缓存过期策略组合。另外也需要决定哪些内容适合缓存，缓存在哪里。

### 14.3.1 应用层以下的缓存

Mysql服务器有自己的内部缓存，但也可以构建你自己的缓存和汇总表。可以对缓存表量身定制，使他们最有效地过滤、排序、与其他表关联、计数，或者用于其他用途。缓存表也比许多应用层换出更持久，因为在服务器重启后他们还存在。

### 14.3.2 应用层缓存

应用层缓存通常在同一台机器的内存中存储数据，或者通过网络存在另一台机器的内存中。

- 本地缓存
- 本地共享内存缓存
- 分布式内存缓存
- 磁盘上的缓存

### 14.3.3 缓存控制策略

- TTL(time to live, 存活时间)
- 显式失效
- 读时失效

### 14.3.4 缓存对象分层

分层缓存对象对检索、失效和内存利用都有帮助。相对于只缓存对象，也可以缓存对象的ID、对象的ID组等通常需要一起检索的数据。

### 14.3.5 预生成内容

出了在应用程序级别缓存位数据，也可以在后台预先请求一些页面，并且将结果存为金泰页面。如果页面是动态的，也可以预先生成页面的部分内容，然后使用像服务端包含（SSI）这样的技术创建最终页面。这有助于减少预生成内容的大小和开销，否则可能在将不同部分拼装到最终页面的时候，由于微小的变化产生大量重复的内容。

### 14.3.6 作为基础组件的缓存

缓存可能成为基础设施的重要组成部分。也很容易陷入一个陷阱，认为缓存虽然很好用，但并不是很重要到非有不可的东西。你也许会辩驳，如果缓存服务器宕机或者缓存被清空，请求也可以直接落在数据库上，系统依然可以正常运行。如果是刚刚将缓存加入应用系统，这也许是对的，但是缓存的加入可以使得在应用压力显著增长时不需要对系统的某些部分同比增加资源通入——通常是数据库部分。因此，系统可能慢慢地变得对缓存非常依赖，缺没有被发觉。

### 14.3.7 使用`HandlerSocket`和 `memcached`

相对于数据存储在Mysql中而缓存在Mysql外部的缓存方案，另外有一种替代方法是为Mysql创建一个更快的访问路径，直接绕过使用缓存。对于小而简单的查询语句，很大一部分开销来自解析SQL，检查权限，生成执行计划，等等。如果这种开销可以避免，Mysql在处理简单查询时将非常快。