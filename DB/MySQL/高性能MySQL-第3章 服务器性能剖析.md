# 第3章 服务器性能剖析

在我们的技术咨询生涯中，最常碰到的三个性能相关的服务请求是：如何确认服务器是否达到了性能最佳的状态，找出某条语句为什么执行不够快，以及诊断被用户表述成”停顿“、”堆积“或者”卡死“的某些间歇性疑难故障。

## 3.1 性能优化简介

我们将性能定义为完成某件任务所需要的时间度量，换句话说，性能即响应时间，这是一个非常重要的原则。我们通过任务和时间而不是资源来测量性能。数据库服务器的目的是执行SQL语句，所以他关注的任务是查询或者语句。数据库服务器的性能用查询的响应时间来度量，单位是每个查询话费的时间。

### 3.1.1 通过性能剖析进行优化

性能剖析是测量和分析时间花费在哪里的主要方法，性能剖析一般有两个步骤：测量任务所花费的时间；然后对结果进行统计和排序，将重要的任务排到前面。

 ### 3.1.2 理解性能剖析

Mysql的性能剖析（profile）将最重要的任务展示在前面，但有时候没显式处理哎的信息也很重要。不幸的是，尽管性能剖析输出了排名、总计和平均值，但还是有很多需要的信息是缺失的，如下所示。

- 值得优化的查询（worthwhile query）

  性能剖析不会自动给出哪些查询值得花时间去优化。

  一些之战总响应时间比重很小的查询时不值得优化的。

- 异常情况

  某些任务即使没有出现在性能剖析的输出的前面也需要优化。比如某些任务执行次数很少，但每次执行都非常满，严重影响用户体验。因为其执行频率低，所以总的响应时间占比并不突出

- 未知的未知

  一款号的性能剖析工具会显示可能的“丢失时间”。丢失的时间指的是任务的总时间和实际测量到的时间之间的差。例如，如果处理器的CPU时间时10秒，而剖析到的任务总时间时9.7秒，那么就有300毫秒的丢失时间。这可能时有些任务没有测量到，也可能是由于测量的误差和精度问题的缘故。

- 被掩藏的细节

  性能剖析无法显示所有响应时间的纷纷不。只相信平均值时非常危险的，他会隐藏很多信息，而且无法表达全部情况。

## 3.2 对应用程序进行性能剖析

对任何需要消耗时间的任务都可以做性能剖析，当然也包括应用程序。实际上，剖析应用程序一般比剖析数据库服务器容易，而且回报更多。性能瓶颈可能有很多影响因素：

- 外部资源，比如调用了外部的web服务器或者搜索引擎。
- 应用需要处理大量的数据，比如分析一个超大的XML文件。
- 在循环中执行昂贵的操作，比如滥用正则表达式。
- 使用了低效的算法，比如使用暴力搜索算法来查找列表中的项。

### 3.2.1 测量PHP应用程序 

略 P74

## 3.3 剖析Mysql查询

可以剖析整个数据库服务器，这样可以分析出哪些查询时主要的压力来源（如果以及在最上面的应用层做过剖析，则可能已经知道哪些查询需要特别留意）。定位到具体需要优化的查询后，也可以钻取下去对这些查询进行单独的剖析，分析哪些子任务是响应时间的主要消耗者。

### 3.3.1 剖析服务器负载

服务器端的剖析很有价值，因为在服务器端可以有效地审计效率低下的查询。定位和优化“坏”查询能够显著的提升应用的性能，也能解决某些特定的难题。还可以降低服务器的整体压力，这样所有的查询都将因为减少了对共享资源的争用而收益（“简介的好处”）。降低服务器的负载也可以推迟或者避免升级更昂贵的硬件需求，还可以发现和定位糟糕的用户体验，比如某些极端情况。有一个工具很早之前就能帮到我们了，这就是慢查询日志。

**捕获Mysql的查询到日志文件中**

在Mysql的当前版本中，满查询日志是开销最低、精度最高的测量查询时间的工具。需要担心的是日志可能消耗大量的磁盘空间。如果长期开启慢查询日志，注意要部署日志轮转工具。或者不要长期启用满查询日志，只在需要收集负载样本的期间开启即可。

Mysql还有另外一种查询日志，被称之为“通用日志”，但很少用于分析和剖析服务器性能。通用日志在查询请求到服务器时进行记录，所以不包含响应时间和执行计划等重要信息。

第二种技术时通过抓取TCP网络包，然后根据Mysql的客户端/服务端通信协议进行解析。可以先通过`tcpdump`将网络包数据保存到磁盘，然后使用`pt-query-digest`的`--type=tcpdump`选项来解析并分析查询。此方法的精度比较高，并且可以捕获所有查询。还可以解析更高级的协议特性，比如可以解析二进制协议，从而创建并执行服务器预解析的语句及压缩协议。另外还有一种方法，就是通过Mysaql Proxy代理层的脚本来记录所有查询，但在实践中我们很少这样做。

**分析查询日志**

强烈建议大家从现在就开始利用慢查询寻日志捕获服务器上的所有查询，并且进行分析。可以在一些典型的时间窗口如业务高峰期的一个小时内记录查询。

不要直接打开整个慢查询日志进行分析，这样做只会浪费时间和金钱。首先应该生成一个剖析报告，如果需要，则可以再查看日志中需要特别关注的部分。自顶向下时比较好的方式，否则有可能像前面提到的，反而导致业务的逆优化。

### 3.3.2 剖析单挑查询

在定位到需要优化的单挑查询后，可以针对此查询“钻取”更多的信息，确认为什么会花费这么长的时间执行，以及需要如何去优化。

- 使用`SHOW PROFILE`

  `SHOW PROFILE`命令 默认是禁用的，但可以通过服务器变量在会话（连接）级别动态地修改。

  ```console
  SET profiling = 1;
  ```

  然后，在服务器上执行的所有语句，都会测量其耗费的时间和其他一些查询执行状态变更相关的数据。这个功能有一定作用，而且最初的设计功能更强大，但未来版本中可能会被Performance Schema所取代。

  当一条查询提交给服务器时，此工具会记录剖析信息到一张临时表，并且给查询赋予一个从1开始的整数标识符。

  详见P82

- 使用 `SHOW STATUS`

  Mysql 的SHOW STATUS 命令返回了一些计数器。既有服务器级别的全局计数器，也有基于某个连接的绘画级别的计数器。例如其中的Queries在绘画开始时为0，每提交一条查询增加1。如果执行SHOW GLOBAL STATUS ，则可以查看服务器级别的从服务器启动时开始计算的查询次数统计。不同计数器的课件范围不一样，不过全局的计数器也会出现在SHOW STATUS的结果中，容易被误认为时绘画级别的，千万不要搞迷糊了。

  详见P84

- 使用慢查询日志

  详见P85

- 使用 Performance Schema

  详见P86

### 3.3.3 使用性能剖析

优化查询时，用户需要对服务器如何执行查询有较深的了解。剖析报告能够尽可能多的手机需要的信息、给出诊断问题的正确方向，以及为其他诸如EXPLAIN等工具提供基础信息。

## 3.4 诊断间歇性问题

间歇性的问题比如系统偶尔停顿或者慢查询，很难诊断。这些幻影问题只在没有注意到的时候才发生，而且无法确认如何重现，诊断这样的问题往往要花费很多时间，有时候甚至需要好几个越。

尽量不要使用是错的方式来解决问题。这种方式有很大的风险，因为结果可能变得更坏。这也是一种令人巨商且抵消的方式。如果一时无法定位问题，可能是测量的方式不正确，或者测量的点选择有误，或者使用的工具不合适（也可能是缺少现成的工具）

为了掩饰为什么要尽量避免试错的诊断方式，下面列举了我们认为已经解决的一些间歇性数据库性能问题的实际案例：

- 应用通过curl从一个运行的很慢的外部服务来后去汇率报价的数据
- *memcached*缓存中的一些重要条目过期，导致大量请求落到Mysql以重新生成缓存条目。
- DNS查询偶尔会有超时现象。
- 可能是由于互斥锁争用，或者内部删除查询缓存的算法效率太低的缘故，Mysql的查询缓存有时候会导致服务有短暂的停顿。
- 当并发超过某个阈值时，InnoDB的扩展性限制导致查询计划的优化需要很长的时间。

### 3.4.1 单条查询问题还是服务器问题

首先要确认这是单挑查询的问题，还是服务器的问题。如果服务器上所有的程序都突然变慢，又突然都编号，每一条查询也都变慢了，那么慢查询可能就不一定时原因，而是由于其他问题导致的结果。

那么如何判断是单挑查询问题还是服务器问题呢？如果问题不停地周期性出现，那么可以在某次活动中观察到；或者整夜运行脚本收集数据，第二天来分析结果。

- 使用 SHOW GLOBAL STATUS 

  这个方法实际上就是以比较高的频率如疫苗执行一次SHOW GLOBAL STATUS 命令捕获数据，问题出现时，则可以通过某些计数器（比如Threads_running、Threads_connected、Questions和Queries）的“尖刺”或者“凹陷”来发现。这个方法比较简单，所有人都可以使用，对服务器影响也很小，所以是一个花费时间不多却能很好地了解问题的好方法。

  详见P89

- 使用SHOW PROCESSLIST

  这个方法是通过不停的捕获 SHOW PROCESSLIST的输出，来观察是否有大量线程处于不正常的状态或者有其他不正常的特征。例如查询很少会长时间处于“statistics”状态，这个状态一般是指服务器在查询优化阶段如何确定关联表的顺序——通常都是非常快的，另外，也很少会见到大量线程报告当前连接用户是“未经验证的用户（Unauthenticated user）”，这只是在连接握手的中间过程的状态，当客户端等待输入用于登录的用户信息的时候才会出现。

  详见P90

- 使用查询日志

  如果要通过查询日志发现问题，需要开启慢查询日志并在全局级别设置long_query_time为0，并且要确认所有的连接都采用了新的设置。这可能需要重置所有连接以使新的全局设置生效。

  查询实在完成阶段才写入到慢日志的，所以堆积会造成大量查询处于完成阶段，知道阻塞其他查询的资源占用者释放资源后，其他的查询才能执行完成。这种行为特征的一个好处使，当遇到吞吐量突然下降时，可以归咎于吞吐量下降后完成的第一个查询（有时候也不一定是第一个查询。当某些查询被阻塞时，其他查询可以不受影响的继续运行，所以不能完全依赖这个经验）。

- 理解发现的问题（Making sense of the findings）

  可视化的数据最具有说服力。

  我们建议诊断问题时先使用前两种方法：SHOW STATUS 和 SHOW PROCESSLIST。这两种方法的开销很低，而且可以通过简单的shell脚本反复执行的查询来交互式的收集数据。

### 3.4.2 捕获诊断数据

当出现间歇性问题时，需要尽可能地收集所有数据，而不只是问题出现时的数据。虽然这样会收集大量的诊断数据，但总比真正能够诊断问题的数据没有被收集到的情况要好。

在开始之前，需要搞清楚两件事：

1. 一个可靠且实时的“触发器”，也就是能区分什么时候问题出现的方法。
2. 一个收集诊断数据的工具。

**诊断触发器**

有两个常见的问题可能导致无法达到预期的结果：误报或者漏检。误报是指收集了很多诊断数据，但期间其实没有发生问题，这可能浪费时间，而且 令人沮丧。而漏检则指在问题出现时没有捕获到数据，错失了机会，一样的浪费时间。所以在开始收集数据前多花一点时间来确认触发器能够真正的识别问题是划算的。

选择一个合适的阈值很重要，既要足够高，以确保在正常时不会被处罚；又不能太高，要确保问题发生时不会错过。

详见P93

**需要收集什么样的数据**

尽可能收集所有能收集的数据，但只在需要的时间段内收集。包括系统的状态、CPU利用率、磁盘使用率和可用空间、ps的输出采样、内存利用率，以及可以从Mysql获得的信息，如 SHOW STATUS 、SHOW PROCESSLIST 和SHOW INNODB STATUS。这些在诊断问题时都需要用到。

详见P94

**解释结果数据**

如果已经正确的设置好了触发条件，并且长时间运行 *pt-stalk*，则只需要等待足够长的时间来捕获几次问题，就能够得到大量的数据来进行筛选。第一，检查问题是否真的发生了，因为有很多的样本数据需要检查，如果是误报就会白白浪费大量的时间。第二，是否有非常明显的跳跃性变化。查看异常的查询或事务的行为，以及异常的服务器内部行为通常都是最有收获的。查询或事务的行为可以显式是否是由于使用服务器的方式导致问题：性能低下的SQL查询、使用不当的索引、设计糟糕的数据库逻辑架构等。

详见P96

### 3.4.3 一个诊断案例

略P98

## 3.5 其他剖析工具

略P106