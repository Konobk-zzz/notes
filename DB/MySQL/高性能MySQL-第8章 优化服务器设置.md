# 第8章 优化服务器设置

MySQL有大量可以修改的参数——但不应该随便去修改。通常只需要把基本的项配置正确（大部分情况下只有很少一些参数是真正重要的），应该将更多的时间花在schema的优化、索引，以及查询设计上。在正确地配置了MySQL的基本配置项之后，再花力气去修改其他配置项的收益通常就比较小了。

## 8.1 MySQL配置的工作原理

首先应该知道的是MySQL之前，我们先来了解一下MySQL从哪里获得配置信息：命令行参数和配置文件。

任何打算长期使用的设置都应该写到全局配置文件，而不是在命令行特别指定。否则，如果偶然在启动时忘了设置就会有风险。把所有的配置文件放在同一个地方以方便检查也是个好办法。

配置文件通常分成多个部分，每个部分的开头是一个用方括号括起来的分段名称。MySQL程序通常读取跟它同名的分段部分，许多客户端程序还会读取client部分，这是一个存放公用设置的地方。服务器通常读取mysqld这一段。一定要确认配置项放在了文件正确的分段中，否则配置是不会生效的。

### 8.1.1 语法、作用域和动态性

配置项设置都使用小写，单词之间用下划线或横线隔开。

配置项可以有多个作用域。有些设置是服务器级的（全局作用域），有些对每个连接是不同的（会话作用域），剩下的一些是对象级的。许多会话级变量跟全局变量相等，可以认为是默认值。如果改变会话级变量，它只影响改动的当前连接，当连接关闭时所有参数变更都会失效。

如果在服务器运行时修改了变量的全局值，这个值对当前会话和其他任何已经存在的会话都不起效果，这是因为会话的变量值在连接创建时从全局值初始化来的。在每次变更之后，应该检查 `SHOW GLOBAL VARIABLES` 的输出，确认已经按照期望变更了。

有些变量使用了不同的单位，所以必须知道每个变量的正确单位。许多变量可以通过后缀指定单位，但只能在配置文件或者作为命令行参数时才有效。当使用SQL的SET命令时，必须使用数字值1048576，或者1024*1024这样的表达式。但在配置文件中不能使用表达式。

有个特殊的值可以通过SET命令赋值给变量：DEFAULT。把这个值赋给会话级变量可以把变量改为使用全局值，把它赋值给全局变量可以设置这个变量为编译内置的默认值（不是在配置文件中指定的值）。

### 8.1.2 设置变量的副作用

动态设置变量可能导致意外的副作用，例如从缓冲中刷新脏块。无比小心哪些可以在线更改的设置，因为它们可能导致数据库做大量的工作。

对于连接级别的设置，不要轻易地在全局级别增加它们的值，除非确认这样做时对的。有一些缓存会一次性分配执行大小的全部内存，而不管实际上是否需要这么大，所以一个很大的全局设置可能导致浪费内存。更好的办法是，当查询需要时，在连接级别单独调大这些值。

另外，即使时非常小的排序操作，排序缓存也会分配全部大小的内存，所以如果把参数设置得超过平均排序需求太多，将会浪费很多内存，增加额外的内存分配开销。内存分配也是昂贵的操作，内存分配包括了地址空间的分配，这相对来说时比较昂贵的。

### 8.1.3 入门

设置变量时请小心，并不是值越大就越好，而且如果设置的值太高，可能更容易导致问题：可能会由于内存不足导致服务器内存交换，或者超过地址空间。

应该始终通过监控来确认生产环境中变量的修改，是提高还是降低了服务器的整体性能。基准测试是不够的，因为基准测试不是真实的工作负载。如果不对服务器的性能进行实际的测量，可能性能降低了都没有发现。我们见过很多情况，有人修改了服务器的配置，并认为它提高了性能，其实服务器的整体性能恶化了，因为在一个星期或者一天的不同时间，工作负载是不一样的。

配置文件中写好注释，并建议使用版本控制。

### 8.1.4 通过基准测试迭代优化

你也许期望通过建立一套基准测试方案，然后不断迭代地验证对配置项的修改来找到最佳配置方案。通常我们都不建议大家这么做。这需要做非常多的工作和研究，并且大部分情况下潜在的收益是非常小的，这可能导致巨大的时间浪费。而把时间花在检查备份、监控执行计划的变动之类的事情上，可能会更有意义。

即使更改一个选项后基准测试出现了提升，也无法知道长期运行后这个变更会有说明副作用。基准测试也不能衡量一切，或者没有运行足够长的时间来检测系统的长期稳定性，修改就可能导致如周期性性能抖动或者周期性的慢查询等问题。这是很难察觉到的。

如果必须这样做，我们建议再开始配置服务器之前，开发一个定制的基准测试包。你必须做这些事情来包含所有可能的工作负载，甚至包含一些边缘的场景，例如很庞大很复杂的查询语句。在实际的数据上重放工作负载通常是一个好办法。

最好的办法是一次改变一个或两个变量，每次一点点，每次更改后运行基准测试，确保运行足够长的时间来确认性能是否稳定。

## 8.2 什么不该做

在我们开始配置服务器之前，希望鼓励大家去避免一些我们已经发现有风险或有害的做法。

搜先，不要根据一些“比率”来调优。一个经典的按“比率”调优的经验法则是，键缓存的命中率应该高于某个百分比，如果命中率过低，则应该增加缓存的大小。这时非常错误的意见。无论别人怎么跟你说，缓存命中率跟缓存是否过大或者过小没有关系。首先，命中率取决于工作负载——某些工作负载就是无法缓存的，不管缓存有多大——其次，缓存命中么理由什么意义，我们将在后面解释原因。

另外说一句，在互联网搜索如何配置并不总是一个好主意。在博客、论坛等地方都可能找到很多不好的建议。虽然许多专家在网上贡献了他们了解的东西，但并不总是能容易地分辨出哪些是正确的建议。

最后，不要相信很流行的内存消耗公式——是的，就是MySQL崩溃时自身输出的那个内存消耗公式（我们这里就不再重复了）。这个公式已经很古老了，它并不可靠，甚至也不是一个理解MySQL在最差的情况下需要使用多少内存的有用的办法。

## 8.3 创建MySQL配置文件

MySQL编译的默认设置并不都是靠谱的，虽然其中大部分都比较合适。它们被设计成不要使用大量的资源，因为MySQL的使用目标是非常灵活的，它并没有假设自己是服务器上唯一的应用。默认情况下，MySQL只是使用恰好足够的资源来启动，运行一些少量数据的简单查询。如果有超过几MB的数据，就一定会需要自己指定MySQL配置。

建议基础配置见P336

InnoDB在大多数情况下如果要运行得很好，配置大小合适的缓冲池（Buffer Pool）和日志文件（Log File）是必须的。默认值都太小了。其他所有的InnoDB设置都是可选的，尽管示例配置中因为可管理性和灵活性的原因启用了innodb_file_per_table。设置InnoDB日志文件的大小和innodb_flush_method 是本章后面要讨论的主题，其中innodb_flush_method是类UNIX系统特有的选项。

有一个流行的经验法则说，应该把缓冲池大小设置为服务器内存的约75%~80%。这时另一个偶然有效的“比率”，但并不总是正确的。有一个更好的办法来设置缓冲池大小，大致如下：

1. 从服务器内存总量开始
2. 减去操作系统的内存占用，如果MySQL不是唯一运行在这个服务器上的程序，还要扣掉其他程序可能占用的内存。
3. 减去一些MySQL自身需要的内存，例如为每个查询操作分配的一些缓冲。
4. 减去足够让操作系统缓存InnoDB日志文件的内存，至少是足够缓存最近经常访问的部分。（此建议适用于标准的MySQL，Percona Server可以配置日志文件用 0_DIRECT 方式打开，绕过操作系统缓存），留一些内存至少可以缓存二进制日志的最后一部分也是个很好的选择，尤其是如果复制产生了延迟，备库就可能读取主库上旧的二进制日志文件，给主库的内存造成一些压力。
5. 减去其他配置的MySQL缓冲和缓存需要的内存，例如MyISAM的键缓存（Key Cache），或者查询缓存（Query Cache）。
6. 除以105%，这差不多接近InnoDB管理缓冲池增加的自身管理开销。
7. 把结果四舍五入，向下取一个合理的数值。向下舍入不会太影响结果，但是如果分配太多可能就会是件很糟糕的事情。

### 8.3.1 检查MySQL服务器状态变量

有时可以使用SHOW GLOBAL STATUS的输出，作为配置的输入，以更好地通过工作负载来自定义配置。为了达到最佳效果，既要看绝对值，又要看值是如何随时间而改变你的，最好为高峰和非高峰时间的值做几个快照。可以使用一下命令每隔60秒来查看状态变量的增量变化：

```console
mysqladmin extended-status -ri60
```

## 8.4 配置内存使用

配置MySQl正确地使用内存量对高性能是至关重要的。肯定要根据需求来定制内存使用。可以认为MySQL的内存消耗分为两类：可以控制的内存和不可以控制的内存。无法设置MySQL服务器运行，解析查询，以及其内部管理所消耗的内存，但是为特定目的而使用多少内存则有很多参数可以控制。用好可以控制的内存并不难，但需要对配置的含义非常清楚。

像前面展示的，按下面的步骤来配置内存：

1. 确定可以使用的内存上限。
2. 确定每个连接MySQL需要使用多少内存，例如排序缓冲和临时表。
3. 确定操作系统需要多少内存才够用。包括同一台机器上其他程序使用的内存，如定时任务。
4. 把剩下的内存全部给MySQL的缓存，例如InnoDB的缓冲池，这样做很有意义。

### 8.4.1 MySQL可以使用多少内存

在任何给定的操作系统上，MySQL都有允许使用的内存上限。基本出发点是机器上安装了多少物理内存。

还需要考虑操作系统或架构的限制，如果32位操作系统对一个给定的进程可以处理多少内存是有限制的。因为MySQL是单进程多线程的运行模式，它整体可用的内存量也许会受操作系统位数的严格限制——例如，32位Linux内核通常限制任意进程可以使用的内存量在2.5GB~2.7GB范围内。运行时地址空间溢出是非常危险的，可能导致MySQL崩溃。

有许多其他的操作系统——特殊的参数和古怪的事情必须考虑到，例如不只是每个进程有限制，而且堆栈大小和其他设置也有限制。系统的`glibc`库也可能限制每次分配的内存大小。例如，若`glibc`库支持单次分配的最大大小是2GB，那么可能旧无法设置 `innodb_buffer_pool` 的值大于2GB。

### 8.4.2 每个连接需要的内存

MySQL保持一个连接（线程）只需要少量的内存。它还要求一个基本量的内存来执行任何给定查询。你需要为高峰时期执行的大量查询预留好足够的内存。否则，查询执行可能因为缺乏内存而导致执行效率不佳或执行失败。

相对于计算最坏情况下的开销，更好的办法是观察服务器在真实的工作压力下使用了多少内存，可以在进程的虚拟内存大小哪里看到。在许多类UNIX系统里，可以观察`top`命令中的VIRT列，或者`ps`命令中的VSZ列的值。

### 8.4.3 为操作系统保留内存

跟查询一样，操作系统也需要保留足够的内存给他工作。如果没有虚拟内存正在交换 （Paging）到磁盘，就是表明操作系统内存足够的最佳迹象。

最少应该为操作系统保留1GB ~ 2GB 的内存——如果机器内存更多旧再多预留一些。我们建议2GB或者总内存的5%作为基准，以较大者为准。为了安全再额外增加一些预留，并且如果机器上还再运行内存密集型任务（如备份），则可以再多增加一些预留。不要为操作系统的缓存增加任何内存，因为它们可能会变得非常大。操作系统通常会利用所有剩下的内存来做文件系统缓存，我们认为，这应该从操作系统自身的需求里分离出来。

### 8.4.4 为缓存分配内存

如果服务器只运行MySQL，所有不需要为操作系统以及查询处理保留的内存都可以用MySQL缓存。

相比其他，MySQL需要为缓存分配更多的内存。它使用缓存来避免磁盘访问，磁盘访问比内存访问数据要慢得多。操作系统可能会缓存一些数据，这些对MySQL有些好处（尤其是对MyISAM），但MySQL自身也需要大量内存。

下面是我们认为对大部分情况来说最重要的缓存：

- InnoDB 缓冲池
- InnoDB 日志文件 和 MyISAM数据的操作系统缓存
- MyISAM键缓存
- 查询缓存
- 无法手工配置的缓存，例如二进制日志和表定义文件的操作系统缓存

还有些其他缓存，但是它们通常不会使用太多内存。

如果只使用单一存储引擎，配置服务器旧简单多了。如果只是用MyISAM表，旧可以完全关闭InnoDB，而如果只是用InnoDB，就只需要分配最少的资源给MyISAM（MySQl内部系统表采用MyISAM）。但是如果正混合使用各种存储引擎，就很难再它们之间找到恰当的平很。我们发现最好的办法是先做一个有格局的猜测，然后再运行中观察服务器（再进行调整）。

### 8.4.5 InnoDB缓冲池（Buffer Pool）

如果大部分都是InnoDB表，InnoDB缓冲池或许比其他任何东西更需要内存。InnoDB缓冲池并不仅仅缓存索引：它还会缓存行的数据、自适应哈希索引、插入缓冲（Insert Buffer）、锁，以及其他内部数据结构。InnoDB还是用缓冲池来帮助延迟写入，这样就能合并多个写入操作，然后一起顺序地协会。总之，InnoDB严重依赖缓冲池，你必须确认为它分配了足够的内存，通常就像这一章前面展示的那样处理。可以使用通过SHOW 命令得到的变量或者例如 *innotop* 这样的工具监控InnoDB缓冲池的内存利用情况。

如果数据量不大，并且不会快速增长，就没必要为缓冲池分配过多的内存。把缓冲池配置的比需要缓存的表和索引还要大很多实际上没有什么意义。当然，对一个迅速增长的数据库做超前的规划没有错，但有时我们也会看到一个巨大的缓冲池只缓存一点点数据，这就没有必要了。

很大的缓冲池也会带来一些挑战，例如，预热和关闭都会花费很长的时间。如果有很多脏页再缓冲池里，InnoDB关闭时可能会花费较长的时间，因为再关闭之前需要把脏页写回数据文件。

### 8.4.6 MyISAM键缓存（Key Caches）

MyISAM的键缓存也被称为键缓冲，默认只有 一个键缓存，但也可以创建多个。不像InnoDB和其他一些存储引擎，MyISAM自身只有缓存索引，不缓存数据（依赖操作系统缓存数据）。如果大部分是MyISAM表，就应该为键缓存分配比较多的内存。

最重要的配置项是key_buffer_size。任何没有分配给他的内存都可以被操作系统缓存利用。MySQL 5.0有一个规定的有效上限是4GB，不管系统是什么架构。MySQL 5.1允许更大的值。可以查看正在使用的MySQL版本的官方手册来了解这个限制。

再决定缓存需要分配多少内存之前，休闲区了解MyISAM索引实际上占用多少磁盘空间是很有帮助的。肯定不需要把键缓冲设置得比需要缓存的索引数据还大。查询INFORMATION_SCHEMA表的INDEX_LENGTH字段，把它们的值相加，就可以得到索引存储占用的空间：

```sql
SELECT SUM(INDEX_LENGTH) FROM INFORMATION_SCHEMA.TABLES WHERE ENGINE='MYISAM';
```

应该把键缓存设置得多大？不要超过索引的总大小，或者不超过为操作系统缓存保留总内存的25%~50%，以更小的为准。

比起键缓冲命中率更需要注意每秒缓冲未命中的次数。假定有一个独立的磁盘，每秒可以做100个随机读。每秒5次缓存未命中可能不会导致I/O繁忙，但是每秒80次缓存未命中则可能出现问题。

记住，MyISAM使用操作系统缓存来缓存数据文件，通常数据文件比索引要大。因此，把更多的内存保留给操作系统缓存而不是键缓存时有意义的。即使你有足够的内存来缓存所有索引，并且键缓存命中率很低，当MySQL尝试读取数据文件时（不是索引文件），在操作系统层还是可能发生缓存未命中，这对MySQL完全透明，MySQL并不能感知到。因此，这种情况下可能会有大量数据文件缓存未命中，这和索引的键缓存未命中率时完全不相关的。

最后，即使没有任何MyISAM表，依然需要将key_buffer_size设置为较小的值，例如32M。MySQL服务器有时会在内部使用MyISAM表，例如GROUP BY语句可能会使用MyISAM做临时表。

**MySQL键缓存块大小（Key Block Size）**

块大小也是很重要的（尤其是写密集型负载），因为它影响了MyISAM、操作系统缓存，以及文件系统之间的交互。如果缓存块太小了，可能会碰到写时读取（read-around write），就是操作系统在执行写操作前必须先从磁盘上读取一些数据。下面说明一下这种情况时怎么发生的，假设操作系统的页大小是4KB（在x86架构上通常都是这样），并且索引块大小是1KB：

1. MyISAM请求从磁盘上读取1KB的块。
2. 操作系统从磁盘上读取4KB的数据并缓存，然后发送需要的1KB数据给MyISAM。
3. 操作系统丢弃缓存数据以给其他数据腾出缓存。
4. MyISAM修改1KB的索引块，然后请求操作系统把他写回磁盘。
5. 操作系统从磁盘读取同一个4KB的数据，写入操作系统缓存，修改MyISAM改动的这1KB数据，然后把整个4KB的块写回磁盘。

在第5步中，当MyISAM请求操作系统去写4KB页的部分内容时，就发生了写时读取。如果MyISAM的块大小跟操作系统的相匹配，在第5步的磁盘读就可以避免。

很遗憾，MySQL 5.0 以及更早的版本中没有办法配置索引块大小。但是，在MySQL  5.1 以及更新版本中，可以设置MyISAM的索引块大小跟操作系统一样，以避免写时读取。`myisam_block_size`变量控制着索引块大小。因为同一个表的所有索引都保存在同一个文件中，因此该表所有索引的块大小都需要大于或者等于操作系统的块大小，才能避免由于边界对齐导致的写时读取。（例如，若同一个表的两个索引，一个块大小是1KB，另一个是4KB。那么4KB的索引块边界很可能和操作系统的页边界时不对其的，这样还是会发生写时读取。）

#### 8.4.7 线程缓存

线程缓存保存那些当没有与连接关联但是准备为后面新的连接服务的线程。当一个新的连接创建时，如果缓存中有线程存在，MySQL从缓存中删除一个线程，并且把它分配给这个新的连接。当链接关闭时，如果线程还有空间的话，MySQL又会把线程放回缓存。如果没有空间的话，MySQL会销毁这个线程。只要MySQL在缓存里还有空闲的线程，他就可以迅速的相应连接请求，因为这样就不用为每个连接创建新的线程。

`thread_cache_size`变量指定了MySQL可以保持在缓存中的线程数。一般不需要配置这个值，除非服务器会有很多连接请求。查看Threads_created状态变量。如果我们观察到很少有每秒创建的新线程数少于10个的时候，通常应该继续保持线程缓存足够大，但是实际上经常也可能看到每秒少于1个新线程的情况。

一个好的办法时官场 Threads_connected 变量并尝试设置 thread_cache_size 足够大以便能处理业务压力正常的波动。例如，若Threads_connected通常保持在100 ~ 120，则可以设置缓存大小为20。如果它保持在 500 ~ 700 ，200的线程缓存应该足够大了。可以这样认为：在700个连接的时候，可能没有线程在缓存中；在500个连接的时候，有200个缓存的线程准备为负载再次增加到700个连接时使用。

把线程缓存设置得非常大在大部分时候时没有必要的，但是设置得很小也不能节省太多内存，所以也没说明好处。每个在线程缓存中的线程或者休眠状态的线程，通常使用256KB左右的内存。相对于正在处理查询的线程来说，这个内存不算很大。通常应该保证线程缓存足够大，以避免 Threads_created 频繁增长。如果这个数字很大（例如，几千个线程），可能需要把 thread_cache_size 设置的稍微小一些，因为一些操作系统不能很好地处理庞大的线程数，即使其中大部分是休眠的。

### 8.4.8 表缓存（Table Cache）

表缓存和线程缓存的概念是相似的，但存储的对象代表的是表。每个在缓存中的对象包含相关表 .frm 文件的解析结果，加上一些其他数据。准确的说，在对象里的其他数据的内容依赖于表的存储引擎。例如，对于MyISAM，是表的数据和索引的文件描述符。对于Merge表则可能是多个文件描述符，因为Merge表可以有很多的底层表。

表缓存可以重用资源。举个实际的例子，当一个查询请求访问一张MyISAM表，MySQL也许可以从缓存的对象中获取到文件描述符。尽管这样做可以避免打开一个文件描述符的开销，但这个开销其实不大。打开和关闭文件描述符在本地存储时很快的，服务器可以轻松的完成每秒100万次的操作（尽管这跟网络存储不同）。对MyISAM表来说，表缓存的真正好处是，可以让服务器避免修改MyISAM文件头来标记表“正在使用中”。

表缓存的设计服务器和存储引擎之间分离不彻底的产物，属于历史问题。表缓存对InnoDB重要性就小很多了，因为InnoDB不依赖它来做那么多的事（例如持有文件描述符，InnoDB有自己的表缓存版本）。尽管如此，InnoDB也能从缓存解析的.frm文件中获益。

在MySQL 5.1 版本中，表缓存分离成两部分：一个是打开表的缓存，一个是表定义缓存（通过 table_open_cache 和 table_definition_cache 变量来配置）。其结果时，表定义（解析 . frm文件的结果）从其他资源中分离出来了，例如表描述符。打开的表依然是每个线程、每个表用的，但是表定义是全局的，可以被所有连接有效地共享。通常可以把 table_definition_cache 设置得足够高，以缓存所有的表定义。除非有上万张表，否则这可能是最简单的方法。

如果 Opened_tables 状态变量很大或者在增长，可能是因为表缓存不够大，那么可以认为增加 table_cache 系统变量（或者是MySQL 5.1中的 table_open_cache）。然而，当创建和删除临时表时，要注意这个计数器的增长，如果经常需要创建和删除临时表，那么该计数器就会不停的增长。

### 8.4.9 InnoDB数据字典（Data Dictionary）

InnoDB有自己的表缓存，可以称为表定义缓存或者数据字典，在目前的MySQL版本中还不能对它进行配置。当InnoDB打开一张表，就增加了一个对应的对象到数据字典。每张表可能占用4KB或者更多的内存（尽管在MySQL 5.1中对空间的需求小了很多）。当表关闭的时候也不会从数据字典中移除它们。

因此，随着时间的推移，服务器可能出现内存泄漏，导致数据字典中的元素不断地增长。但这不是真的内存邪路，只是没有对数据字典实现任何一种缓存过期策略。通常只有当有很多（数千或数万）张大表时才是个问题。

另一个性能问题时第一次打开表时会计算统计信息，这需要很多I/O操作，所以代价很高。相比MyISAM，InnoDB没有将统计信息持久化，而是在每次打开表时重新计算，在打开之后，每隔一段时间或者遇到触发事件（改变表的内容或者查询INFORMATION_SCHEMA表，等等），也会重新计算统计信息。如果有很多表，服务器可能会花费数个小时来启动并完全预热，这个时候服务器可能花费更多的事件在等待I/O操作，而不是做其他事。

即使在启动之后，InnoDB统计操作还可能对服务器和一些特定的查询产生冲击。可以关闭 `innodb_stats_on_metadata` 选项来避免耗时的表统计信息刷新。

如果设置了InnoDB的innodb_file_per_table选项，InnoDB任意时刻可以保持打开 .ibd文件的数量也是有其限制的。这由InnoDB存储引擎负责，而不是MySQL服务器管理，并且由 innodb_open_files 来控制。InnoDB打开文件和MyISAM的方式不一样，MyISAM用表缓存来持有打开表的文件描述符，而InnoDB在打开表和打开文件之间没有直接的关系。InnoDB为每个.ibd文件使用单个、全局的文件描述符。如果可以，最好把 innodb_open_files 的值设置得足够大以使服务器可以保存所有的 .ibd 文件同时打开。

## 8.5 配置MySQL的I/O行为

有一些配置项影响着MySQL怎样同步数据到磁盘以及如何做恢复操作。它们表现了性能和数据安全之间的权衡。通常，保证数据立刻并且一致地写道磁盘时很昂贵的。如果能够冒一点磁盘写可能没有真正持久化到磁盘的风险，就可以增加并发性和减少I/O等待，但是必须决定可以容忍多大的风险。

### 8.5.1 InnoDB I/O 配置

InnoDB 不仅允许控制怎么恢复，还允许控制怎么打开和刷新数据（文件），这回对恢复和整体性能产生巨大的影响。尽管可以影响它的行为，InnoDB的恢复流程实际上时自动的，并且经常在InnoDB启动时运行。对于常见的应用，最重要的一小部分内容是InnoDB日志文件大小、InnoDB怎样刷新它的日志缓冲，以及InnoDB怎样执行I/O。

**InnoDB事务日志**

InnoDB使用日志来减少提交事务时的开销。因为日志中已经记录了事务，就无需再每个事务提交时把缓冲池的脏块刷新（flush）到磁盘中。事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多的随机I/O。 InnoDB假设使用的是常规磁盘（机械磁盘），随机I/O比顺序I/O要昂贵得多，因为一个I/O请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。

InnoDB用日志把随机I/O变成顺序I/O。一旦日志安全写到磁盘，事务就持久化了，即使变更还没写到数据文件。如果一些糟糕的事情发生了（例如断电了），InnoDB可以重放日志并恢复已经提交的事务。

InnoDB的日志有固定的大小。InnoDB的日志是环形方式写的：当写到日志的尾部，会重新跳转到抬头继续写，但不会覆盖还没应用到数据文件的日志记录，因为这样做会清掉已提交事务的唯一持久化记录。

InnoDB使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。

当InnoDB变更任何数据时，会写一条变更记录到内存日志缓冲区。再缓冲满的时候、事务提交的时候，或者每一秒，InnoDB都会刷写缓冲区的内容到磁盘日志文件。

InnoDB怎样刷新日志缓冲。当InnoDB把日志缓冲刷新到磁盘日志文件时，会先使用一个Mutex锁住缓冲区，刷新到所需要的位置，然后移动身下的条目到缓冲区的前面。当Mutex释放时，可能有超过一个事务已经准备好刷新其日志记录。InnoDB有一个Group Commit功能，可以在一个I/O操作内提交多个事务，但是在MySQL 5.0中打开二进制日志时这个功能就不能用了。

**InnoDB怎样打开和刷新日志以及数据文件**

使用innodb_flush_method选项可以配置InnoDB如何跟文件系统相互作用。从名字来看，会以为只能影响InnoDB怎么写数据，实际上还影响了InnoDB怎么读数据。Windows和非Windows的操作系统对这个选项的值时互斥的：async_unbuffered、unbuffered和normal只能在Windows下使用，并且Windows下不能使用其他的值。在Windows下默认值时unbuffered，其他操作系统都是fdatasync。（如果 SHOW GLOBAL VARIABLES 显示这个变量为空，意味着它被设置为默认值了。）

**InnoDB表空间**

InnoDB把数据保存在表空间内，本质上是一个由一个或多个磁盘文件组成的虚拟文件系统。InnoDB用表空间实现很多功能，并不是只存储表和索引。它还保存了回滚日志（旧版本行）、插入缓冲（Insert Buffer）、双写缓冲（Doublewrite Buffer），以及其他内部数据结构。

 innodb_file_per_table选项让InnoDB为每张表使用一个文件。它在数据字典存储名为“表名.ibd”的数据。这使得删除一张表时回收空间简单多了，并且可以容易地分散表到不同的磁盘上。

设置innodb_file_per_table也有不好的一面：更差的DROP TABLE性能。这可能足以导致显而易见的服务器端阻塞。因为由如下两个原因：

- 删除表需要从文件系统层去掉（删除文件），这可能在某些文件系统（ext3，说的就是你）上会很慢。可以通过欺骗文件系统来缩短这个过程：把 .ibd 文件连接到一个0字节的文件，然后手动删除这个文件，而不用等待MySQL来做。
- 当打开这个选项，每张表都在InnoDB中使用自己的表空间。结果是，移除表空间实际上需要InnoDB锁定和扫描缓冲池，查找属于这个表空间的页面，在一个有庞大的缓冲池的服务器上做这个操作是非常慢的。如果打算删除很多InnoDB表（包括临时表）并且用了innodb_file_per_table，可能会从 Percona Server包含的一个修复中获益，它可以让服务器慢慢地清理掉属于被删除表的页面。只需要设置innodb_lazy_drop_table这个选项。

**行的旧版本和表空间**  在一个写压力大的环境下，InnoDB的表空间可能增长得非常大。如果事务保持打开状态很久（即使它们没有做任何事），并且使用默认的REPEATABLE READ事务隔离级别，InnoDB将不能删除旧的行版本，因为没提交的事务依然需要看到它们。InnoDB把旧版本存在共享表空间，所以如果有更多的数据在更新，共享表空间会持续增长。有时这个问题并非是没提交的事务的原因，也可能使工作负载的问题：清理过程只有一个线程处理，直到最近的MySQL版本才改进，这可能导致清理线程处理速度跟不上旧版本行数增加的速度。



**双写缓冲（Doublewrite Buffer）**

InnoDB用双写缓冲来避免页没写完整所导致的数据损坏。当一个磁盘写操作不能完整地完成时，不完整的页写入就可能发生，16KB的页可能只有一部分被写到磁盘上。 

双写缓冲是表空间一个特殊的保留区域，在一些连续的块中足够保存100个页。本质上是一个最近写回的页面的备份拷贝。当InnoDB从缓冲池刷新页面到磁盘是，首先把它们写（或者刷新）到双写缓冲，然后再把它们写到其所属的数据区域中。这可以保证每个页面的写入都是原子并且持久化的。

这意味着每个页都要写两遍，但是因为InnoDB写页面到双写缓冲是顺序的，并且只调用一次fsync() 刷新到磁盘，所以实际上对性能的冲击时比较小的。这个策略允许日志文件更加高效。因为双写缓冲给InnoDB一个非常牢固的保证，数据页不会损坏，InnoDB日志记录没必要包含整个页，它们更像是页面的二进制变化量。

如果有一个不完整的页写到了双写缓冲，原始的页依然会在磁盘上它的真实位置。当InnoDB恢复时，它将用原始页面替换掉双写缓冲中的损坏页面。然而，如果双写缓冲成功写入，但写到页的真实位置失败了，InnoDB在恢复时将使用双写缓冲中的拷贝来替换。InnoDB直到生命时候页面损坏了，因为每个页面在末尾都有校验值。校验值时最后写到页面的东西，所以如果页面的内容跟校验值不匹配，说明这个页面是损坏的。因此，在恢复的时候，InnoDB只需要读取双写缓冲中每个页面并且验证校验值。如果一个页面的校验值不对，就从它的原始位置读取这个页面。



**其他的I/O配置项**

sync_binlog 选项控制MysQL怎么刷新二进制日志到磁盘。默认值是0，意味着MySQL并不刷新，由操作系统自己决定什么时候刷新到持久化设备。如果这个值比0大，它指定了两次刷新到磁盘的动作之间间隔多少次二进制日志写操作（如果autocommit被设置了，每个独立的语句都是一次写，否则就是一个事务一次写）。把它设置为0和1以外的值是很罕见的。

像InnoDB日志文件一样，把二进制日志放到一个带有电池保护的写缓存的RAID卷，可以极大地提升性能。事实上，写和刷新二进制日志缓存其实比InnoDB十五日至要昂贵的多了，因为不像InnoDB事务日志，每次写二进制日志都会增加它们的大小。这需要每次写入文件系统都更新元信息。所以，设置sync_binlog=1可能比innodb_flush_log_at_trx_commit=1对性能的损害要大得多，尤其是网络文件系统。

### 8.5.2 MyISAM的I/O配置

MyISAM通常每次写操作之后就把索引变更刷新磁盘。如果你打算在一张表上做很多修改，那么毫无疑问，批量操作会更快一些。一种办法是用LOCK TABLES延迟写入，直到解锁这些表。这是个提升性能的很有价值的技巧，因为它使得你精确控制哪些写被延迟，以及什么时候把它们刷新到磁盘。可以精确延迟哪些希望延迟的语句。

通过设置 `delay_key_write` 变量，也可以延迟索引的写入。如果这么做，修改的键缓冲块直到表被关闭才会刷新。可能的配置如下：

- OFF

  MyISAM每次写操作后刷新键缓冲（键缓存，Key Buffer）中的脏块到磁盘，除非表被LOCK TABLES锁定了。

- ON

  打开延迟键写入，但是只对用DELAY_KEY_WRITE 选项创建的表有效。

- ALL

  所有的MyISAM表都会使用延迟键写入。

延迟键写入在某些场景下可能很有帮助，到那时通常不会带来很大的性能提升。当键缓冲的读命中很好但写命中不好时，数据又比较小，这可能很有用。当然也有一小部分缺点：

- 如果服务器缓存并且块没有被刷到磁盘，索引可能会损坏。
- 如果很多写被延迟了，MySQL可能需要花费更长时间去关闭表，因为必须等待缓冲刷新到磁盘。在MySQL 5.0 这可能引起很馋的表缓存锁。
- 由于上面提到的原因， FLUSH TABLES 可能需要很长时间。如果为了做逻辑卷（LVM）快照或者其他备份操作，而执行FLUSH TABLES WITH READ LOCK，那可能增加操作的时间。
- 建缓冲中没有刷回去的脏块可能占用空间，导致从磁盘上读取的新块没有空间存放。因此，查询语句可能需要等待MyISAM释放一些键缓存的空间。

另外，除了配置MyISAM的索引I/O还可以配置MyISAM怎样尝试从损坏中恢复。myisam_revcover选项控制MyISAM怎样寻找和修复错误。

打开这个选项通知MySQL在表打开时，检查是否损坏，并且在找到问题的时候进行修复。可以设置的值如下：

- DEFAULT（或者不设置）

  时MySQL尝试修复任何被标记为崩溃或者没有标记为完全关闭的表。默认值不要求在恢复时执行其他动作。**跟大多数变量不同**，这里DEFAULT值不是重置变量的值为编译值；它本质上意味着“没有设置”。

- BACKUP

  让MySQL将数据文件的备份写到.BAK文件，以便随后进行检查。

- FORCE

  即使 .MYD 文件中丢失的数据可能超过一行，也让恢复继续。

- QUICK

  除非有删除块，否则跳过恢复。块中有已经删除的行也依然会占用空间，但是可以被后面的INSERT语句重用。这可能比较哟用，因为MyISAM大表的恢复可能花费相当长的时间。

可以使用多个设置，用逗号分隔。例如“BACKUP，FORCE”会强制恢复并且创建备份。这是为什么我们在这一张前面部分的示例配置中这么用的原因。

我们建议打开这个选项，尤其是只有一些小的MyISAM表时。服务器运行着一些损坏的MyISAM表时很危险的，因为它们有时可以导致更多数据损坏，甚至服务器崩溃。然而，如果有很大的表，原子恢复时不切实际的：它导致服务器打开所有的MyISAM表时都会检查和修复，这是低效的做法。这段时间，MySQL会阻止连接做任何工作。如果有一大堆的MyISAM表，比较好的主意还是启动后用CHECK TABLES 和 REPAIR TABLES 命令来做，这样对服务器影响比较少。不管哪种方式，检查和修复表都是很重要的。

打开数据文件和内存映射（MMAP）访问是另一个有用的MyISAM选项。内存映射使得MyISAM直接通过操作系统的页面缓存访问 .MYD 文件，避免系统调用的开销。在MySQL 5.1和更新的版本中，可以通过 myisam_use_mmap 选项打开内存映射。更老版本的MySQL只能对压缩时的MyISAM表使用内存映射。

## 8.6 配置MySQL并发

### 8.6.1 InnoDB并发配置

InnoDB架构在有限的内存、单CPU、单磁盘的系统中仍然暴露出一些根本性问题。在高并发场景下，InnoDB的某些方面的性能可能会降低，唯一的办法是限制并发。

最基本的限制并发的方式是使用`innodb_thread_councurrency`变量，它会限制一次性可以有多少线程进入内核，0表示不限制。如果在旧的MySQL版本里有InnoDB并发问题，这个变量是最重要的配置之一。

在任何架构和业务压力下，给这个变量设置一个“靠谱”的值都很重要，理论上，下面的公式可以给出一个这样的值：

**并发值 = CPU数量 * 磁盘数量 * 2**

但是在实践中，使用更小的值会更好一点。必须做实验来找出适合系统的最好的值。

如果已经进入内核的线程超过了允许的数量，新的线程旧无法再进入内核。InnoDB使用两端处理来尝试让线程尽可能高效地进入内核。两端策略减少了因操作系统调度引起的上下文切换。线程第一次休眠 innodb_thread_sleep_delay 微秒，然后再重试。如果它依然不能进入内核，则放入一个等待队列，让操作系统来处理。

第一阶段的默认的休眠时间是10000 微秒。当CPU有大量的线程处在“进入队列前的休眠”状态，因而没有被充分利用时，改变这个值在高并发环境里可能会有帮助。如果有大量的小查询，默认值可能也太大了，因为这增加了10毫秒的查询延迟。

一旦线程进入内核，它会有一定数量的“票据（TIckets）”，可以让它“免费”返回内核，不需要再做并发检查。这限制了一个线程返回到其他线程之前可以做多少事。innodb_concurrency_tickets 选项控制票据的数量。它很少需要修改，除非有很多运行时间极长的查询。票据是按查询授权的，不是按事务。一旦查询完成，它没用完的票据旧销毁了。

除了缓冲池和其他结构的瓶颈，还有另一个提交阶段的并发瓶颈，这个时候I/O非常密集，因为需要做刷新操作。innodb_commit_concurrency 变量控制有多少个线程可以在同一时间提交。如果 innodb_thread_concurrency 配置得很低也有大量的线程冲突，那么配置这个选项可能会有帮助。

最后，有一个新的解决方案值得考虑：使用线程池（Thread Pool）来限制并发。原始的线程池实现已经随着MySQL 6.0 的代码树一起被废弃了，并且有严重缺陷。但是MariaDB已经重新实现了，并且Oracle 最近放出了一个商业插件可以为MySQL 5.5 提供线程池功能。对这些东西我们都没有足够的经验来直到你这么做，你也许会更加困惑，因为我们会指出这两种实现似乎都不满足Facebook，它在自己内部私有的MySQL分支中有一个叫做“准入控制”的特殊功能。如果可能的话，在这本书的第四版我们将分享一些线程池的知识，以及说明时候它们可以工作，什么时候不能工作。

### 8.6.2 MyISAM并发配置

在某些条件下，MyISAM也允许并发插入和读取，这使得可以“调度”某些操作以尽可能少的产生阻塞。

MyISAM删除操作不会重新整理整个表，它们只是把行标记为删除，在表中留下“空洞”。MyISAM倾向于在可能的时候填满这些空洞，在插入行时重新利用这些空间。如果没有空洞了，他就把新行插入表的末尾。

尽管MyISAM是表级锁，它依然可以一边读取，一边并发追加新行。这种情况下只能读取到查询开始时的所有数据，新插入的数据时不可见的。这样可以避免不一致读。

然而，若表中间的某些数据变动了的话，还是难以提供一致读。MVCC是解决这个问题最流行的方法：一旦修改者创建了新版本，它就让读者读数据的旧版本。可是，MyISAM并不像InnoDB那样支持MVCC，所以除非插入操作在表的末尾，否则不能支持并发插入。

通过设置 concurrent_insert 这个变量，可以配置MyISAM打开并发插入，可以配置为如下值：

- 0

  MyISAM不允许并发插入，所有插入都会对表加互斥锁。

- 1

  这是默认值。只要表中没有空洞，MyISAM就允许并发插入。

- 2

  这个值在MySQL 5.0以及更新版本中有效。他强制并发插入到表的末尾，即使表中有空洞。如果没有线程从表中读取数据，MySQL将把新行放在空洞里。使用这个设置通常会使表更加碎片化。

如果合并操作可以更加高效，也可以配置MySQL对一些操作进行延迟。举个实例，可以通过delay_key_write 变量延迟写索引，正如这一章前面我们提到的。这牵涉到熟悉的权衡：立即写索引（安全但是昂贵），或者等待但是祈求在写发生前别断电（更快，但是遇到崩溃时可能引起巨大的索引损坏，因为索引文件已经过期了）。

也可以让 INSERT、REPLACE、DELETE、以及UPDATE语句的优先级比SELECT语句更低，设置`low_priority_updates`选项就可以了。这相当于把LOW_PRIORITY修饰符应用到全局UPDATE语句。当使用MyISAM时，这是个非常重要的选项，这让SELECT 语句可以获得相当好的并发度，否则一小部分获取高优先级写锁的语句就可能导致SELECT语句无法获取资源。

## 8.7 基于工作负载的配置

配置服务器的一个目标是把它定制得符合特定的工作负载。这需要精通所有类型的服务器活动的数量、类型、以及频率——不仅仅是查询语句，也包括其他的活动，例如连接服务器以及刷新表。

第一件应该做的事情是熟悉你的服务器，如果还没做就赶紧。当服务器在满载情况下运行时，请尝试记录所有的查询语句，因为这是最好的方式来查看那种类型的查询语句占用资源最多。同时，创建processlist快照，通过state或者 command字段来聚合他们。例如，是否大量地在复制数据到临时表，或者排序数据？如果有，也许需要优化查询语句，以及查看临时表和排序缓冲配置项。

### 8.7.1优化BLOB和TEXT的场景

BLOB和TEXT列对MySQL来说是特殊类型的场景（我们把所有BLOB和TEXT都简单称为BLOB类型，因为他们属于相同的类型的数据）。BLOB值有几个限制使得服务器对它的处理跟其他类型不一样。一个最重要的主义事项是，服务器不能再内存临时表中存储BLOB值，因此，如果一个查询涉及BLOB值，又需要使用临时表——不管他多小——他都会立即在磁盘上创建临时表。这样效率很低，尤其是对小而快的查询。临时表可能是查询中最大的开销。

有两种办法来减轻这个不利的情况：通过SUBSTRING()函数（第4章有更多关于这个函数的细节）把值转换为VARCHAR，或者让临时表更快一些。

让临时表运行更快的最好方式是，把它们放在基于内存的文件系统（GNU/Linux上是tmpfs）。这会降低一些开销，尽管这依然比内存表慢许多。因为操作系统会避免吧数据写到磁盘，所以内存文件系统可以帮助提升性能。一般的文件系统也会在内存中缓存，但是操作系统会每隔几秒就刷新一次。tmpfs文件系统从来不会刷新，他就是为低开小和简单起见而设计的。例如，没必要为这个文件系统预备任何恢复方案。这使得他更快。

服务器设置里控制临时表文件放在哪的是tmpdir。建议监控文件系统使用使用频率以保证有足够的空间存放临时。如果需要，可以指定多个临时表存放位置，MySQL将会轮询使用。

如果BLOB列非常大，并且用的是InnoDB，也许可以调大InnoDB日志缓冲大小。

对于很长的变长列（列如，BLOB、TEXT，以及长字符列），InnoDB存储一个768字节的前缀在行内。如果列的值比前缀长，InnoDB会在行外分配扩展存储空间来存剩下的部分，它会分配一个完整的16KB的页，像其他所有的InnoDB页面一样，每个列都有自己的页面（不同的列不会共享扩展存储空间）。InnoDB一次只为一个列分配一个页的扩展存储空间，直到使用超过32个页以后，就会一次性分配64个页面。

注意，我们说过InnoDB可能会分配扩展存储空间。如果总的行长（包括大字段的完整长度）比InnoDB的最大行长度限制要短（比8KB小一些），InnoDB将不会分配扩展存储空间，即使大字段（Long clolumn）的长度超过了前缀长度。

最后，当InnoDB更新存储在扩展存储空间中的大字段时，将不会在原来的位置更新。而是会在扩展存储空间中写一个新值到一个新的位置，并且不会删除旧的值。

所有这一切都有一下后果：

- 大字段在InnoDB里可能浪费大量空间。
- 扩展存储禁用了自适应哈希，因为需要完整地比例的整个长度，才能发现是否是正确的数据（哈希帮助InnoDB非常快速地找到“猜测的位置”，但是必须检查“检测的位置”是不是正确）。因为自适应哈希是完全的内存结构，并且直接指向Buffer Pool中访问“最”频繁的页面，但对于扩展存出空间却无法使用自适应哈希。
- 太长的值可能使得在查询中作为WHERE 条件不能使用索引，因而执行很慢。
- 如果一张表里有很多大字段，最好是把它们组合起来单独存放到一个列里面，比如说用XML文档格式存储。这让所有的大字段共享一个扩展存储空间，这比每个字段用自己的页要好。
- 有时候可以把大字段用COMPRESS() 压缩后再存为BLOB，或者在发送到MySQL前在应用程序中进行压缩，这可以获得显著的空间优势和性能收益。

### 8.7.2 优化排序（Filesorts）

从第6章我们知道MySQL有两种排序算法。如果查询中所有需要的列和ORDER BY的列总大小超过 max_length_for_sort_data 字节，则采用two-pass算法。或者当任何需要的列——即使没有被ORDER BY使用的列——是BLOB或者TEXT，也会采用这个算法。（可以用SUBSTRING()把这些列转换一下，就可以用single-pass算法了。）

MySQL有两个变量可以控制排序怎样执行。通过修改 `max_length_for_sort_data` 变量的值，可以影响MySQL选择哪种排序算法。因为 single-pass算法为每行需要排序的数据创建一个固定大小的缓冲，对于VARCHAR列，在和max_length_for_sort_data 比较时，使用的是其定义的最大长度，而不是所存储数据的实际长度。这也是为什么我们建议只选择必要的列的一个原因。

当MySQL必须排序BLOB或TEXT字段时，它只会使用前缀，然后忽略剩下部分的值。这是因为缓冲只能分配固定大小的结构体来保存要排序的值，然后从扩展存储空间中复制前缀到这个结构体。使用max_sort_length 变量可以指定这个前缀有多大。

可惜，MySQL无法查看它用了哪个算法。如果增加了max_length_for_sort_data 变量的值，磁盘使用率上升了，CPU使用率下降了，并且Sort_merge_passes状态变量相对与修改之前开始很快地上升，也许是强制让很多的排序使用了single-pass算法。

## 8.8 完成基本配置

- tmp_table_size 和 max_heap_table_size

  这两个设置控制使用Memory引擎的内存临时表能使用多大内存。如果隐式内存临时表的大小超过这两个设置的值，将会被转换为磁盘MyISAM表，所以它的大小可以继续增长。（隐式临时表是一种并非由自己创建，而是服务器创建，用于保存执行行中查询的中间结果的表。）

- max_connections

  这个设置的作用就像一个紧急刹车，以保证服务器不会因为应用程序激增的连接而不堪重负。如果应用程序有问题，或者服务器遇到如连接延迟的问题，会创建很多新连接。但是如果不能执行查询，那打开一个连接没有好处，所以被”太多的连接“的错误拒绝是一种快速而代价小的失败方式。

- thread_cache_size

  设置这个变量，可以通过观察服务器一段时间的活动，来计算一个有理有据的值。观察 Threads_connected 状态变量并且找到它在一般情况下的最大值和最小值。你也许希望把线程缓存设置得足够大，以在高峰和嘀咕时都足够，甚至可能更大方一些，因为就算设置得有点太大了，一般也不是大问题。

- table_cache_size

  这个缓存（或者在MySQL 5.1 中被分成两个缓存区）应该被设置得足够大，以避免总是需要重新打开和重新解析表的定义。

## 8.9 安全和稳定的设置

- expire_log_days

  如果启用了二进制日志，应该打开这个选项，可以让服务器在指定的天数之后清理旧的二进制日志。

- max_allowed_packet

  这个设置防止服务器发送太大的包，也会控制多大的包可以被接收。默认值可能太小了，但设置得太大页可能有危险。如果设置的太小，有时复制上会出现问题，通常表现为备库不能接受主库发过来的复制数据。

- max_connect_errors

  如果有时网络短暂抽风了，或者应用配置出现错误，或者有另外的问题，如权限，在短暂的时间内不断地尝试连接，客户端可能被列入黑名单，然后无法连接，知道再次刷新主机缓存。

- skip_name_resolve

  这个选项禁用了另一个网络相关的鉴权认证相关的陷阱:DNS查找。DNS是MySQL连接过程中的一个薄弱环节。当连接服务器时，默认情况下，它视图确定连接和使用的主机的主机名，作为身份验证凭据的一部分。（就是说，你的凭据时用户名，主机名、以及密码——并不只是用户名和密码）但是验证主机来源，服务器需要执行DNS的正向和反向查找。要是DNS有问题旧悲剧了，在某些时间点这是必然的事。当发生这样的情况时，所有事都会堆积起来，最终导致连接超时。为了避免这种情况，我们强烈建议设置这个选项，在验证时关闭DNS查找。然而，如果这么做，需要把基于主机名的授权改为用IP地址、通配符，或者特定主机名”localhost“，因为基于主机名的账号将会被禁用。

- sql_mode

  这个设置可以接受多种多样的值来改变服务器行为。

- sysdata_is_now

  这是另一个可能导致与应用预期向后不兼容的选项。但如果不是明确需要SYSDATE() 函数的非确定性行为（非确定性行为可能会导致复制中断或者使得基于时间点的备份恢复结果不可信），那么你可能希望打开该选项以确保SYSDATE() 函数有确定的行为。

下面的选项可以控制复制行为，并且对防止备库出问题非常有帮助：

- read_only

  这个选项禁止没有特权的用户在备库做变更，只接受从主库传输过来的变更，不接受从应用来的变更。我们强烈建议把备库设置为只读模式。

- skip_slave_start

  这个选项阻止MySQL试图自动启动复制。因为在不安全的崩溃或其他问题后，启动复制时不安全的，所以需要禁用自动启动，用户需要手动检查服务器，并确定他是安全的之后再开始复制。

- slave_net_timeout

  这个选项控制备库发现跟主库的连接以及失败并且需要重连之前等待的时间。默认值是一个小时，太长了。设置为一分钟或更短。

-  sync_master_info 、 sync_relay_log、 sync_relay_log_info

  这些选项，在MySQL 5.5以及更新版本中可用，解决了复制中备库长期存在的问题：不把他们的状态文件同步到磁盘，所以服务器崩溃后可能需要人来猜测复制的位置实际上在主库是哪个位置，并且可能在中继日志（Relay Log）里有损坏。

## 8.10 高级InnoDB设置

- innodb

  如果把这个值设置为FORCE，只有在InnoDB可以启动时，服务器才会启动。如果使用InnoDB作为默认存储引擎，这一定是你期望的结果。

- innodb_autoinc_lock_mode

  这个选项控制InnoDB如何生成自增主键值，某些情况下，例如高并发插入时，自增主键可能是个瓶颈。如果有很多事务等待自增锁（可以在SHOW ENGINE INNODB STATUS里看到），应该审视这个变量的设置。

- innodb_buffer_pool_instances

  这个选项可以把缓冲池切分为多端，这可能是在高负载的多核机器上提升MySQL可扩展性的最重要的一个方式了。多个缓冲池分散了工作压力，所以一些全局Mutex竞争就没有那么大了。

- innodb_io_capacity

  InnoDB曾经在代码里写死了假设服务器运行在每秒100个I/O操作的单硬盘上。默认值很糟糕。现在可以告诉InnoDB服务器有多大的I/O能力。InnoDB有时需要把这个值设置得相当高（在像PCI-E SSD 这样极快的存储设备上需要设置为上万）才能稳定地刷新脏页，原因解释起来相当复杂。

- innodb_read_io_threads 和 innodb_write_io_threads

  这些选项控制有多少后台线程可以被I/O操作使用。最近的MySQL里，默认值是4个读线程和4个写线程，对于大部分服务器这都足够了。如果有很多硬盘并且工作负载并发很大，可以发现这些线程很难跟上，这种情况下可以增加线程数，或者可以简单地把这个选项的值设置为可以提供I/O能力的磁盘数量（即使后面是一个RAID控制器）。

- innodb_strict_mode

  这个设置让MySQL在某些条件下把警告改成抛错，尤其是无效的或者可能有风险的CREATE TABLE选项。如果打开这个设置，就必然会检查所有 CREATE TABLE选项，因为它不会让你创建一些用起来比较爽（但是有隐患）的表。有时这有点非官，过于严格了。当尝试恢复备份时可能就不希望打开这个选项了。

- innodb_old_blocks_time

  InnoDB有两段缓冲池LRU（最近最少使用）链表，设计目的是防止换出长期使用很多次的页面。像 mysqldump 产生的这种一次性的（大）查询，通常会读取页面到缓冲池的LRU列表，从中读取需要的行，然后移动到下一页。理论上，两段LRU链表将阻止此页面取代很长一段时间内都需要用到的页面放入”年轻（Young）“子链表，并且只在它已被浏览过多次后将其移动到”年老（Old）“子链表。但是InnoDB默认没有配置为防止这种情况，因为页内有很多行，所以从页面读取的行的多次访问，会导致它立即被转义到”年老（Old）“子链表，对哪些需要长时间缓存的页面带来换出的压力。

  这个变量指定一个页面从LRU链表的”年轻“部分转移到”年老“部分之前必须经过的毫秒数。默认情况下它设置为0，将它设为诸如1000毫秒这样的小一点的值，在我们的基准测试中已被证明非常有效。