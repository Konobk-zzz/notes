# 第8章 优化服务器设置

MySQL有大量可以修改的参数——但不应该随便去修改。通常只需要把基本的项配置正确（大部分情况下只有很少一些参数是真正重要的），应该将更多的时间花在schema的优化、索引，以及查询设计上。在正确地配置了MySQL的基本配置项之后，再花力气去修改其他配置项的收益通常就比较小了。

## 8.1 MySQL配置的工作原理

首先应该知道的是MySQL之前，我们先来了解一下MySQL从哪里获得配置信息：命令行参数和配置文件。

任何打算长期使用的设置都应该写到全局配置文件，而不是在命令行特别指定。否则，如果偶然在启动时忘了设置就会有风险。把所有的配置文件放在同一个地方以方便检查也是个好办法。

配置文件通常分成多个部分，每个部分的开头是一个用方括号括起来的分段名称。MySQL程序通常读取跟它同名的分段部分，许多客户端程序还会读取client部分，这是一个存放公用设置的地方。服务器通常读取mysqld这一段。一定要确认配置项放在了文件正确的分段中，否则配置是不会生效的。

### 8.1.1 语法、作用域和动态性

配置项设置都使用小写，单词之间用下划线或横线隔开。

配置项可以有多个作用域。有些设置是服务器级的（全局作用域），有些对每个连接是不同的（会话作用域），剩下的一些是对象级的。许多会话级变量跟全局变量相等，可以认为是默认值。如果改变会话级变量，它只影响改动的当前连接，当连接关闭时所有参数变更都会失效。

如果在服务器运行时修改了变量的全局值，这个值对当前会话和其他任何已经存在的会话都不起效果，这是因为会话的变量值在连接创建时从全局值初始化来的。在每次变更之后，应该检查 `SHOW GLOBAL VARIABLES` 的输出，确认已经按照期望变更了。

有些变量使用了不同的单位，所以必须知道每个变量的正确单位。许多变量可以通过后缀指定单位，但只能在配置文件或者作为命令行参数时才有效。当使用SQL的SET命令时，必须使用数字值1048576，或者1024*1024这样的表达式。但在配置文件中不能使用表达式。

有个特殊的值可以通过SET命令赋值给变量：DEFAULT。把这个值赋给会话级变量可以把变量改为使用全局值，把它赋值给全局变量可以设置这个变量为编译内置的默认值（不是在配置文件中指定的值）。

### 8.1.2 设置变量的副作用

动态设置变量可能导致意外的副作用，例如从缓冲中刷新脏块。无比小心哪些可以在线更改的设置，因为它们可能导致数据库做大量的工作。

对于连接级别的设置，不要轻易地在全局级别增加它们的值，除非确认这样做时对的。有一些缓存会一次性分配执行大小的全部内存，而不管实际上是否需要这么大，所以一个很大的全局设置可能导致浪费内存。更好的办法是，当查询需要时，在连接级别单独调大这些值。

另外，即使时非常小的排序操作，排序缓存也会分配全部大小的内存，所以如果把参数设置得超过平均排序需求太多，将会浪费很多内存，增加额外的内存分配开销。内存分配也是昂贵的操作，内存分配包括了地址空间的分配，这相对来说时比较昂贵的。

### 8.1.3 入门

设置变量时请小心，并不是值越大就越好，而且如果设置的值太高，可能更容易导致问题：可能会由于内存不足导致服务器内存交换，或者超过地址空间。

应该始终通过监控来确认生产环境中变量的修改，是提高还是降低了服务器的整体性能。基准测试是不够的，因为基准测试不是真实的工作负载。如果不对服务器的性能进行实际的测量，可能性能降低了都没有发现。我们见过很多情况，有人修改了服务器的配置，并认为它提高了性能，其实服务器的整体性能恶化了，因为在一个星期或者一天的不同时间，工作负载是不一样的。

配置文件中写好注释，并建议使用版本控制。

### 8.1.4 通过基准测试迭代优化

你也许期望通过建立一套基准测试方案，然后不断迭代地验证对配置项的修改来找到最佳配置方案。通常我们都不建议大家这么做。这需要做非常多的工作和研究，并且大部分情况下潜在的收益是非常小的，这可能导致巨大的时间浪费。而把时间花在检查备份、监控执行计划的变动之类的事情上，可能会更有意义。

即使更改一个选项后基准测试出现了提升，也无法知道长期运行后这个变更会有说明副作用。基准测试也不能衡量一切，或者没有运行足够长的时间来检测系统的长期稳定性，修改就可能导致如周期性性能抖动或者周期性的慢查询等问题。这是很难察觉到的。

如果必须这样做，我们建议再开始配置服务器之前，开发一个定制的基准测试包。你必须做这些事情来包含所有可能的工作负载，甚至包含一些边缘的场景，例如很庞大很复杂的查询语句。在实际的数据上重放工作负载通常是一个好办法。

最好的办法是一次改变一个或两个变量，每次一点点，每次更改后运行基准测试，确保运行足够长的时间来确认性能是否稳定。

## 8.2 什么不该做

在我们开始配置服务器之前，希望鼓励大家去避免一些我们已经发现有风险或有害的做法。

搜先，不要根据一些“比率”来调优。一个经典的按“比率”调优的经验法则是，键缓存的命中率应该高于某个百分比，如果命中率过低，则应该增加缓存的大小。这时非常错误的意见。无论别人怎么跟你说，缓存命中率跟缓存是否过大或者过小没有关系。首先，命中率取决于工作负载——某些工作负载就是无法缓存的，不管缓存有多大——其次，缓存命中么理由什么意义，我们将在后面解释原因。

另外说一句，在互联网搜索如何配置并不总是一个好主意。在博客、论坛等地方都可能找到很多不好的建议。虽然许多专家在网上贡献了他们了解的东西，但并不总是能容易地分辨出哪些是正确的建议。

最后，不要相信很流行的内存消耗公式——是的，就是MySQL崩溃时自身输出的那个内存消耗公式（我们这里就不再重复了）。这个公式已经很古老了，它并不可靠，甚至也不是一个理解MySQL在最差的情况下需要使用多少内存的有用的办法。

## 8.3 创建MySQL配置文件

MySQL编译的默认设置并不都是靠谱的，虽然其中大部分都比较合适。它们被设计成不要使用大量的资源，因为MySQL的使用目标是非常灵活的，它并没有假设自己是服务器上唯一的应用。默认情况下，MySQL只是使用恰好足够的资源来启动，运行一些少量数据的简单查询。如果有超过几MB的数据，就一定会需要自己指定MySQL配置。

建议基础配置见P336

InnoDB在大多数情况下如果要运行得很好，配置大小合适的缓冲池（Buffer Pool）和日志文件（Log File）是必须的。默认值都太小了。其他所有的InnoDB设置都是可选的，尽管示例配置中因为可管理性和灵活性的原因启用了innodb_file_per_table。设置InnoDB日志文件的大小和innodb_flush_method 是本章后面要讨论的主题，其中innodb_flush_method是类UNIX系统特有的选项。

有一个流行的经验法则说，应该把缓冲池大小设置为服务器内存的约75%~80%。这时另一个偶然有效的“比率”，但并不总是正确的。有一个更好的办法来设置缓冲池大小，大致如下：

1. 从服务器内存总量开始
2. 减去操作系统的内存占用，如果MySQL不是唯一运行在这个服务器上的程序，还要扣掉其他程序可能占用的内存。
3. 减去一些MySQL自身需要的内存，例如为每个查询操作分配的一些缓冲。
4. 减去足够让操作系统缓存InnoDB日志文件的内存，至少是足够缓存最近经常访问的部分。（此建议适用于标准的MySQL，Percona Server可以配置日志文件用 0_DIRECT 方式打开，绕过操作系统缓存），留一些内存至少可以缓存二进制日志的最后一部分也是个很好的选择，尤其是如果复制产生了延迟，备库就可能读取主库上旧的二进制日志文件，给主库的内存造成一些压力。
5. 减去其他配置的MySQL缓冲和缓存需要的内存，例如MyISAM的键缓存（Key Cache），或者查询缓存（Query Cache）。
6. 除以105%，这差不多接近InnoDB管理缓冲池增加的自身管理开销。
7. 把结果四舍五入，向下取一个合理的数值。向下舍入不会太影响结果，但是如果分配太多可能就会是件很糟糕的事情。

### 8.3.1 检查MySQL服务器状态变量

有时可以使用SHOW GLOBAL STATUS的输出，作为配置的输入，以更好地通过工作负载来自定义配置。为了达到最佳效果，既要看绝对值，又要看值是如何随时间而改变你的，最好为高峰和非高峰时间的值做几个快照。可以使用一下命令每隔60秒来查看状态变量的增量变化：

```console
mysqladmin extended-status -ri60
```

## 8.4 配置内存使用

配置MySQl正确地使用内存量对高性能是至关重要的。肯定要根据需求来定制内存使用。可以认为MySQL的内存消耗分为两类：可以控制的内存和不可以控制的内存。无法设置MySQL服务器运行，解析查询，以及其内部管理所消耗的内存，但是为特定目的而使用多少内存则有很多参数可以控制。用好可以控制的内存并不难，但需要对配置的含义非常清楚。

像前面展示的，按下面的步骤来配置内存：

1. 确定可以使用的内存上限。
2. 确定每个连接MySQL需要使用多少内存，例如排序缓冲和临时表。
3. 确定操作系统需要多少内存才够用。包括同一台机器上其他程序使用的内存，如定时任务。
4. 把剩下的内存全部给MySQL的缓存，例如InnoDB的缓冲池，这样做很有意义。

### 8.4.1 MySQL可以使用多少内存

在任何给定的操作系统上，MySQL都有允许使用的内存上限。基本出发点是机器上安装了多少物理内存。

还需要考虑操作系统或架构的限制，如果32位操作系统对一个给定的进程可以处理多少内存是有限制的。因为MySQL是单进程多线程的运行模式，它整体可用的内存量也许会受操作系统位数的严格限制——例如，32位Linux内核通常限制任意进程可以使用的内存量在2.5GB~2.7GB范围内。运行时地址空间溢出是非常危险的，可能导致MySQL崩溃。

有许多其他的操作系统——特殊的参数和古怪的事情必须考虑到，例如不只是每个进程有限制，而且堆栈大小和其他设置也有限制。系统的`glibc`库也可能限制每次分配的内存大小。例如，若`glibc`库支持单次分配的最大大小是2GB，那么可能旧无法设置 `innodb_buffer_pool` 的值大于2GB。

### 8.4.2 每个连接需要的内存

MySQL保持一个连接（线程）只需要少量的内存。它还要求一个基本量的内存来执行任何给定查询。你需要为高峰时期执行的大量查询预留好足够的内存。否则，查询执行可能因为缺乏内存而导致执行效率不佳或执行失败。

相对于计算最坏情况下的开销，更好的办法是观察服务器在真实的工作压力下使用了多少内存，可以在进程的虚拟内存大小哪里看到。在许多类UNIX系统里，可以观察`top`命令中的VIRT列，或者`ps`命令中的VSZ列的值。

### 8.4.3 为操作系统保留内存

跟查询一样，操作系统也需要保留足够的内存给他工作。如果没有虚拟内存正在交换 （Paging）到磁盘，就是表明操作系统内存足够的最佳迹象。

最少应该为操作系统保留1GB ~ 2GB 的内存——如果机器内存更多旧再多预留一些。我们建议2GB或者总内存的5%作为基准，以较大者为准。为了安全再额外增加一些预留，并且如果机器上还再运行内存密集型任务（如备份），则可以再多增加一些预留。不要为操作系统的缓存增加任何内存，因为它们可能会变得非常大。操作系统通常会利用所有剩下的内存来做文件系统缓存，我们认为，这应该从操作系统自身的需求里分离出来。

### 8.4.4 为缓存分配内存

如果服务器只运行MySQL，所有不需要为操作系统以及查询处理保留的内存都可以用MySQL缓存。

相比其他，MySQL需要为缓存分配更多的内存。它使用缓存来避免磁盘访问，磁盘访问比内存访问数据要慢得多。操作系统可能会缓存一些数据，这些对MySQL有些好处（尤其是对MyISAM），但MySQL自身也需要大量内存。

下面是我们认为对大部分情况来说最重要的缓存：

- InnoDB 缓冲池
- InnoDB 日志文件 和 MyISAM数据的操作系统缓存
- MyISAM键缓存
- 查询缓存
- 无法手工配置的缓存，例如二进制日志和表定义文件的操作系统缓存

还有些其他缓存，但是它们通常不会使用太多内存。

如果只使用单一存储引擎，配置服务器旧简单多了。如果只是用MyISAM表，旧可以完全关闭InnoDB，而如果只是用InnoDB，就只需要分配最少的资源给MyISAM（MySQl内部系统表采用MyISAM）。但是如果正混合使用各种存储引擎，就很难再它们之间找到恰当的平很。我们发现最好的办法是先做一个有格局的猜测，然后再运行中观察服务器（再进行调整）。

### 8.4.5 InnoDB缓冲池（Buffer Pool）

如果大部分都是InnoDB表，InnoDB缓冲池或许比其他任何东西更需要内存。InnoDB缓冲池并不仅仅缓存索引：它还会缓存行的数据、自适应哈希索引、插入缓冲（Insert Buffer）、锁，以及其他内部数据结构。InnoDB还是用缓冲池来帮助延迟写入，这样就能合并多个写入操作，然后一起顺序地协会。总之，InnoDB严重依赖缓冲池，你必须确认为它分配了足够的内存，通常就像这一章前面展示的那样处理。可以使用通过SHOW 命令得到的变量或者例如 *innotop* 这样的工具监控InnoDB缓冲池的内存利用情况。

如果数据量不大，并且不会快速增长，就没必要为缓冲池分配过多的内存。把缓冲池配置的比需要缓存的表和索引还要大很多实际上没有什么意义。当然，对一个迅速增长的数据库做超前的规划没有错，但有时我们也会看到一个巨大的缓冲池只缓存一点点数据，这就没有必要了。

很大的缓冲池也会带来一些挑战，例如，预热和关闭都会花费很长的时间。如果有很多脏页再缓冲池里，InnoDB关闭时可能会花费较长的时间，因为再关闭之前需要把脏页写回数据文件。

### 8.4.6 MyISAM键缓存（Key Caches）

MyISAM的键缓存也被称为键缓冲，默认只有 一个键缓存，但也可以创建多个。不像InnoDB和其他一些存储引擎，MyISAM自身只有缓存索引，不缓存数据（依赖操作系统缓存数据）。如果大部分是MyISAM表，就应该为键缓存分配比较多的内存。

最重要的配置项是key_buffer_size。任何没有分配给他的内存都可以被操作系统缓存利用。MySQL 5.0有一个规定的有效上限是4GB，不管系统是什么架构。MySQL 5.1允许更大的值。可以查看正在使用的MySQL版本的官方手册来了解这个限制。

再决定缓存需要分配多少内存之前，休闲区了解MyISAM索引实际上占用多少磁盘空间是很有帮助的。肯定不需要把键缓冲设置得比需要缓存的索引数据还大。查询INFORMATION_SCHEMA表的INDEX_LENGTH字段，把它们的值相加，就可以得到索引存储占用的空间：

```sql
SELECT SUM(INDEX_LENGTH) FROM INFORMATION_SCHEMA.TABLES WHERE ENGINE='MYISAM';
```

应该把键缓存设置得多大？不要超过索引的总大小，或者不超过为操作系统缓存保留总内存的25%~50%，以更小的为准。

比起键缓冲命中率更需要注意每秒缓冲未命中的次数。假定有一个独立的磁盘，每秒可以做100个随机读。每秒5次缓存未命中可能不会导致I/O繁忙，但是每秒80次缓存未命中则可能出现问题。

记住，MyISAM使用操作系统缓存来缓存数据文件，通常数据文件比索引要大。因此，把更多的内存保留给操作系统缓存而不是键缓存时有意义的。即使你有足够的内存来缓存所有索引，并且键缓存命中率很低，当MySQL尝试读取数据文件时（不是索引文件），在操作系统层还是可能发生缓存未命中，这对MySQL完全透明，MySQL并不能感知到。因此，这种情况下可能会有大量数据文件缓存未命中，这和索引的键缓存未命中率时完全不相关的。

最后，即使没有任何MyISAM表，依然需要将key_buffer_size设置为较小的值，例如32M。MySQL服务器有时会在内部使用MyISAM表，例如GROUP BY语句可能会使用MyISAM做临时表。

**MySQL键缓存块大小（Key Block Size）**

块大小也是很重要的（尤其是写密集型负载），因为它影响了MyISAM、操作系统缓存，以及文件系统之间的交互。如果缓存块太小了，可能会碰到写时读取（read-around write），就是操作系统在执行写操作前必须先从磁盘上读取一些数据。下面说明一下这种情况时怎么发生的，假设操作系统的页大小是4KB（在x86架构上通常都是这样），并且索引块大小是1KB：

1. MyISAM请求从磁盘上读取1KB的块。
2. 操作系统从磁盘上读取4KB的数据并缓存，然后发送需要的1KB数据给MyISAM。
3. 操作系统丢弃缓存数据以给其他数据腾出缓存。
4. MyISAM修改1KB的索引块，然后请求操作系统把他写回磁盘。
5. 操作系统从磁盘读取同一个4KB的数据，写入操作系统缓存，修改MyISAM改动的这1KB数据，然后把整个4KB的块写回磁盘。

在第5步中，当MyISAM请求操作系统去写4KB页的部分内容时，就发生了写时读取。如果MyISAM的块大小跟操作系统的相匹配，在第5步的磁盘读就可以避免。

很遗憾，MySQL 5.0 以及更早的版本中没有办法配置索引块大小。但是，在MySQL  5.1 以及更新版本中，可以设置MyISAM的索引块大小跟操作系统一样，以避免写时读取。`myisam_block_size`变量控制着索引块大小。因为同一个表的所有索引都保存在同一个文件中，因此该表所有索引的块大小都需要大于或者等于操作系统的块大小，才能避免由于边界对齐导致的写时读取。（例如，若同一个表的两个索引，一个块大小是1KB，另一个是4KB。那么4KB的索引块边界很可能和操作系统的页边界时不对其的，这样还是会发生写时读取。）

#### 8.4.7 线程缓存

线程缓存保存那些当没有与连接关联但是准备为后面新的连接服务的线程。当一个新的连接创建时，如果缓存中有线程存在，MySQL从缓存中删除一个线程，并且把它分配给这个新的连接。当链接关闭时，如果线程还有空间的话，MySQL又会把线程放回缓存。如果没有空间的话，MySQL会销毁这个线程。只要MySQL在缓存里还有空闲的线程，他就可以迅速的相应连接请求，因为这样就不用为每个连接创建新的线程。

`thread_cache_size`变量指定了MySQL可以保持在缓存中的线程数。一般不需要配置这个值，除非服务器会有很多连接请求。查看Threads_created状态变量。如果我们观察到很少有每秒创建的新线程数少于10个的时候，通常应该继续保持线程缓存足够大，但是实际上经常也可能看到每秒少于1个新线程的情况。

一个好的办法时官场 Threads_connected 变量并尝试设置 thread_cache_size 足够大以便能处理业务压力正常的波动。例如，若Threads_connected通常保持在100 ~ 120，则可以设置缓存大小为20。如果它保持在 500 ~ 700 ，200的线程缓存应该足够大了。可以这样认为：在700个连接的时候，可能没有线程在缓存中；在500个连接的时候，有200个缓存的线程准备为负载再次增加到700个连接时使用。

把线程缓存设置得非常大在大部分时候时没有必要的，但是设置得很小也不能节省太多内存，所以也没说明好处。每个在线程缓存中的线程或者休眠状态的线程，通常使用256KB左右的内存。相对于正在处理查询的线程来说，这个内存不算很大。通常应该保证线程缓存足够大，以避免 Threads_created 频繁增长。如果这个数字很大（例如，几千个线程），可能需要把 thread_cache_size 设置的稍微小一些，因为一些操作系统不能很好地处理庞大的线程数，即使其中大部分是休眠的。

### 8.4.8 表缓存（Table Cache）

表缓存和线程缓存的概念是相似的，但存储的对象代表的是表。每个在缓存中的对象包含相关表 .frm 文件的解析结果，加上一些其他数据。准确的说，在对象里的其他数据的内容依赖于表的存储引擎。例如，对于MyISAM，是表的数据和索引的文件描述符。对于Merge表则可能是多个文件描述符，因为Merge表可以有很多的底层表。

表缓存可以重用资源。举个实际的例子，当一个查询请求访问一张MyISAM表，MySQL也许可以从缓存的对象中获取到文件描述符。尽管这样做可以避免打开一个文件描述符的开销，但这个开销其实不大。打开和关闭文件描述符在本地存储时很快的，服务器可以轻松的完成每秒100万次的操作（尽管这跟网络存储不同）。对MyISAM表来说，表缓存的真正好处是，可以让服务器避免修改MyISAM文件头来标记表“正在使用中”。

表缓存的设计服务器和存储引擎之间分离不彻底的产物，属于历史问题。表缓存对InnoDB重要性就小很多了，因为InnoDB不依赖它来做那么多的事（例如持有文件描述符，InnoDB有自己的表缓存版本）。尽管如此，InnoDB也能从缓存解析的.frm文件中获益。

在MySQL 5.1 版本中，表缓存分离成两部分：一个是打开表的缓存，一个是表定义缓存（通过 table_open_cache 和 table_definition_cache 变量来配置）。其结果时，表定义（解析 . frm文件的结果）从其他资源中分离出来了，例如表描述符。打开的表依然是每个线程、每个表用的，但是表定义是全局的，可以被所有连接有效地共享。通常可以把 table_definition_cache 设置得足够高，以缓存所有的表定义。除非有上万张表，否则这可能是最简单的方法。

如果 Opened_tables 状态变量很大或者在增长，可能是因为表缓存不够大，那么可以认为增加 table_cache 系统变量（或者是MySQL 5.1中的 table_open_cache）。然而，当创建和删除临时表时，要注意这个计数器的增长，如果经常需要创建和删除临时表，那么该计数器就会不停的增长。

### 8.4.9 InnoDB数据字典（Data Dictionary）

InnoDB有自己的表缓存，可以称为表定义缓存或者数据字典，在目前的MySQL版本中还不能对它进行配置。当InnoDB打开一张表，就增加了一个对应的对象到数据字典。每张表可能占用4KB或者更多的内存（尽管在MySQL 5.1中对空间的需求小了很多）。当表关闭的时候也不会从数据字典中移除它们。

因此，随着时间的推移，服务器可能出现内存泄漏，导致数据字典中的元素不断地增长。但这不是真的内存邪路，只是没有对数据字典实现任何一种缓存过期策略。通常只有当有很多（数千或数万）张大表时才是个问题。

另一个性能问题时第一次打开表时会计算统计信息，这需要很多I/O操作，所以代价很高。相比MyISAM，InnoDB没有将统计信息持久化，而是在每次打开表时重新计算，在打开之后，每隔一段时间或者遇到触发事件（改变表的内容或者查询INFORMATION_SCHEMA表，等等），也会重新计算统计信息。如果有很多表，服务器可能会花费数个小时来启动并完全预热，这个时候服务器可能花费更多的事件在等待I/O操作，而不是做其他事。

即使在启动之后，InnoDB统计操作还可能对服务器和一些特定的查询产生冲击。可以关闭 `innodb_stats_on_metadata` 选项来避免耗时的表统计信息刷新。

如果设置了InnoDB的innodb_file_per_table选项，InnoDB任意时刻可以保持打开 .ibd文件的数量也是有其限制的。这由InnoDB存储引擎负责，而不是MySQL服务器管理，并且由 innodb_open_files 来控制。InnoDB打开文件和MyISAM的方式不一样，MyISAM用表缓存来持有打开表的文件描述符，而InnoDB在打开表和打开文件之间没有直接的关系。InnoDB为每个.ibd文件使用单个、全局的文件描述符。如果可以，最好把 innodb_open_files 的值设置得足够大以使服务器可以保存所有的 .ibd 文件同时打开。

## 8.5 配置MySQL的I/O行为

有一些配置项影响着MySQL怎样同步数据到磁盘以及如何做恢复操作。它们表现了性能和数据安全之间的权衡。通常，保证数据立刻并且一致地写道磁盘时很昂贵的。如果能够冒一点磁盘写可能没有真正持久化到磁盘的风险，就可以增加并发性和减少I/O等待，但是必须决定可以容忍多大的风险。

### 8.5.1 InnoDB I/O 配置

InnoDB 不仅允许控制怎么恢复，还允许控制怎么打开和刷新数据（文件），这回对恢复和整体性能产生巨大的影响。尽管可以影响它的行为，InnoDB的恢复流程实际上时自动的，并且经常在InnoDB启动时运行。对于常见的应用，最重要的一小部分内容是InnoDB日志文件大小、InnoDB怎样刷新它的日志缓冲，以及InnoDB怎样执行I/O。