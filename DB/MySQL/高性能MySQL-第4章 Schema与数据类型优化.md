# 第4章 Schema与数据类型优化

在数据库中，**schema（发音 “skee-muh” 或者“skee-mah”，中文叫模式）是数据库的组织和结构**，schemas 和schemata都可以作为复数形式。模式中包含了schema对象，可以是表(table)、列(column)、数据类型(data type)、视图(view)、存储过程(stored procedures)、关系(relationships)、主键(primary key)、外键(foreign key)等。

良好的逻辑设计和物理设计是高性能的基石，应该根据系统将要执行的查询语句来设计schema，这往往需要权衡各种因素。例如，反范式的设计可以加快某些类型的查询，但同时可能使另一些类型的查询变慢。比如添加计数表和汇总表使一种很好的优化查询的方式，但这些表的维护成本可能会很高。

## 4.1 选择优化的数据类型

Mysql支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。以下有几个简单的原则有助于做出更好的选择。

- **更小的通常更好**

  一般情况下。应该尽量使用可以正确存储数据的最小数据类型。**更小的数据类型通常更快，因为他们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少**。

- **简单就好**

  **简单数据类型的操作通常需要更少的CPU周期**。例如，整形比字符操作代价更低，因为字符集和校对规则（排序规则）使字符串比较比整形比较更复杂。这里有两个例子，一个使应该使用Mysql内建的类型而不是字符串来存储日期和时间，另外一个使应该用整形存储IP地址。

- **尽量避免NULL**

  很多表都包含可为NULL（空值）的列，即使应用程序并不需要保存NULL也是如此，这是因为可为NULL是列的默认属性。通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值。

  如果查询中**包含可为NULL的列，对Mysql来说更难优化**，因为**可为NULL的列使得索引、索引统计和值比较都更复杂**。因为NULL的列会使用更多的存储空间，在Mysql里也需要特殊处理。当**可为NULL的列被索引时，每个索引记录需要一个额外的字节**，在MyISAM里甚至还可能导致固定大小的索引（例如只有一个整数列的索引）变成可变大小的索引。

  通常把可为NULL的列改为NOT NULL带来的性能提升比较小，所以（调优时）没有必要首先在现有schema中查找并修改掉这种情况，除非确定这会导致问题。但是，如果计划在列上建索引，就应该尽量避免设计成可为NULL的列。

  当然也有例外，例如值得一提的是**InnoDB使用单独的位（bit）存储NULL值**，所以**对于稀疏数据又很好的空间效率**。但这一点不适用于MyISAM。

### 4.1.1 整数类型

有两种类型的数字：整数和实数。如果存储整数，可以使用这几种整数类型：**TINYINT**, **SAMLLINT**, **MEDIUMINT**, **INT**, **BIGINT**。分别使用**8， 16 ，24，32， 64**位存储空间。条目可以存储的值的范围从-2^(N-1) 到 2^(N-1) - 1，其中N是存储空间的位数。

整数类型有可选的UNSIGND属性，表示不允许负值，这大致可以使正数的上限提高一倍。例如 TINYINT UNSIGNED 可以存储的范围是 0 ~ 255，而TINYINT的存储范围是 -128~127。

**有符号和无符号类型使用相同的存储空间，并具有相同的性能**，因此可以更具实际情况选择合适的类型。

你的选择决定Mysql是怎么在内存和磁盘中保存数据的。然而，**整数计算一般使用64位的 BIGINT整数**，即使在32位环境也是如此。（一些聚合函数是例外，他们使用DECIMAL 或 DOUBLE进行计算）。

MySQL可以位整数类型指定宽度，例如INT(11)，对于大多数应用这是没有意义的：它**不会限制值的合法范围**，只是规定了Mysql的一些交互工具（例如Mysql命令行客户端）用来显示字符的个数。对于存储和计算来说，INT（1）和INT（20）是相同的。

### 4.1.2 实数类型

实数是带有小数部分的数字。然而，它们不只是为了存储小数部分；也**可以使用DECIMAL存储比BIGINT还大的整数**。Mysql即支持精确类型，也支持不精确类型。

**DECIMAL类型用于存储精确的小数**。

因为CPU不支持对DECIMAL的直接计算，所以在MYSQL5.0以及更高版本中，Mysql服务器自身实现了DECIMAL的高精度计算。相对而言，CPU直接支持原生浮点计算，所以浮点运算明显更快。

浮点和DECIMAL类型都可以指定精度。对于DECIMAL列，可以指定小数点前后所允许的最大位数。这回影响列的空间消耗。MYSQL 5.0 和更高版本**将数字打包保存到一个二进制字符串中（每4个字节存9个数字）**.例如，DECIMAL（18，9）小数点两边将各存储9个数字，一共使用9个字节：小数点前的数字用4个字节，小数点后的数字用4个字节，小数点本身占1个字节。

Mysql 5.0 和更高版本中的DECIMAL类型**允许最多65个数字**。而早期的MYSQL版本中这个限制是254个数字，并且保存位未压缩的字符串（每个数字一个字节）。然而，这些（早期）版本实际上并不能在计算中使用这么大的数字，因为DECIMAL只是一种存储格式：在计算中DECIMAL会转换成DOUBLE类型。

有多种方法可以指定浮点列所需要的精度，这回使得MYSQL悄悄选择不同的数据类型，或者在存储时对值进行取舍。这些精度定义时非标准的，所以我们直接指定数据类型，不指定精度。

浮点类型在存储同样范围的值时，通常比DECIMAL使用更少的空间。**FLOAT使用4个字节存储**。**DOUBLE占用8个字节**，相比FLOAT有更高的精度和更大的范围。和整数类型一样，能选择的只是存储类型：**MYSQL使用DOUBLE作为内部浮点计算的类型**。

因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用DECIMAL——例如存储财务数据。但在数据量比较大的时候，可以考虑使用BIGINT待敌DECIMAL，将需要存储的货币单位根据小数的位数乘以相应的倍数即可。假设要存储财务数据精确到万分之一分，则可以把所有金额乘以一百万，然后将结果存储在BIGINT里，这样可以同时避免浮点存储计算不精确和DECIMAL精确计算代价高的问题。

### 4.1.3 字符串类型

MYSQL支持多种字符串类型，每种类型还有很多变种。这些数据类型在4.1 和 5.0版本发生了很大的变化，使得情况更加复杂。从MYSQL4.1开始，每个字符串可以定义自己的**字符集**和**排序规则**，或者说校对规则（collation）（更多关于这个主题的信息请参考第7章）。这些东西会很大程度上影响性能。

**VARCHAR和CHAR类型**

VARCHAR 和 CHAR 是两种最主要的字符串类型。不幸的是，很难精确的解释这些值是怎么存储在磁盘和内存中的，因为这跟存储引擎的具体实现有关。下面的描述假设使用的存储引擎是InnoDB和/或者MyISAM。如果使用的不是这两种存储引擎，请参考所使用的存储引擎的文档。

先看看 VARCHAR 和 CHAR值通常在磁盘上怎么存储。请注意，存储引擎存储CHAR 或者 VARCHAR值的方式在内存中和磁盘上可能不一样，所以MYSQL服务器从存储引擎读出的值可能需要转换为另一种存储格式。下面是关于两种类型的一些比较。

- VARCHAR

  VARCHAR类型用于存储**可变长字符串**，是最常见的字符串数据类型。他比定长类型更节省空间，因为它仅使用必要的空间（例如，越短的字符串使用越少的空间）。有一种情况例外，如果MYSQL表使用 ROW_FORMAT=FIXED创建的话，每一行都会使用定长的存储，这会很浪费空间。

   **VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节**。假设采用 latin1 字符集，一个VARCHAR（10）的列需要11个字节的存储空间。VARCHAR(1000)的列则需要1002个字节，因为需要2个字节存储长度信息。

  VARCHAR节省了存储空间，所以对性能也有帮助。但是，由于行是变长的，在UPDATE时可能使行变的比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，在这种情况下，不同的存储引擎的处理方式是不一样的。例如，**MyISAM会将行拆成不同的片段存储**，**InnoDB则需要分裂页来使行可以放进页内**。其他一些存储引擎也许从不在原数据位置更新数据。

  下面这些情况使用VARCHAR是合适的：字符串列的最大长度比平均长度大很多；**列的更新很少**，所以碎片不是问题；**使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储**。

  在5.0或者更高版本，Mysql在**存储和检索时会保留末尾空格**。但在4.1或更老的版本，Mysql会提出末尾空格。

  InnoDB则更灵活，它可以把过长的VARCHAR存储位BLOB，我们稍后讨论这个问题。

- CHAR

  CHAR类型是**定长**的：MYSQL总是根据定义的字符串长度分配足够的空间。当**存储CHAR值时，MYSQL会删除所有的末尾空格**（在MYSQL4.1和更老版本中VARCHAR也是这样实现的——也就是说这些版本中CHAR和VARCHAR在逻辑上时一样的，区别只是在存储格式上）。**CHAR值会根据需要采用空格进行填充以方便比较**。

  CHAR适合存储很短的字符串，或者所有值都接近同一个长度。例如，CHAR非常适合存储密码的MD5值，因为这是一个定长的值。对于**经常变更的数据**，CHAR也比VARCHAR更好，因为定长的**CHAR类型不容易产生碎片**。**对于非常短的列，CHAR比VARCHAR在存储空间上也更有效率**。例如用CHAR(1)来存储只有Y和N的值，如果采用单字节字符集只需要一个字节，但是VARCHAR（1）却需要两个字节，因为还有一个记录长度的额外字节。

**CHAR末尾的空格会被截断，CHAR值会根据需要采用空格进行填充以方便比较。**

**字符串长度定义不是字节数，而是字符数。多字节字符集会需要更多的空间存储单个字符。**

数据如何存储取决于存储引擎，并非所有的存储引擎都会按照相同的方式处理定长和变长的字符串。**Memory引擎只支持定长的行，即使有变长字段也会根据最大长度分配最大空间**。不过，**填充和截取空格的行为在不同存储引擎都是一样的，因为这是在MySQL服务器层进行处理的**。

与CHAR和VARCHAR类似的类型还有BINARY和VARBINARY，它们存储的时二进制字符串。二进制字符串跟常规字符串非常相似，但是**二进制字符串存储的是字节码而不是字符**。填充也不一样：MYSQL**填充BINARY采用的是\0（零字节）而不是空格，在检索时也不会去掉填空值**。

当需要存储二进制数据，并且希望Mysql使用字节码而不是字符进行比较时，这些类型是非常有用的。**二进制比较的优势不仅仅体现在大小写敏感上**。MYSQL比较BINARY字符串时，每次按一个字节，并且根据该字节的数值进行比较。因此，二进制比较比字符比较简单很多，所以也就更快。



> 慷慨是不明智的
>
> 使用VARCHAR(5) 和 VHARCHAR(200)存储 'hello' 的空间开销是一样的。那么使用更短的列有什么优势吗？
>
> 事实证明有很大的优势。更长的列会消耗更多的内存，因为**MYSQL通常会分配固定大小的内存块来保存内部值**。尤其是使用内存临时表进行排序或操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。
>
> 所以最好的策略是只分配真正需要的空间。

   

**BLOB和TEXT类型**

BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用**二进制**和**字符**方式存储。

实际上，它们分别属于两组不同的数据类型加足：字符类型是 **TINYTEXT，SMALLTEXT，TEXT，MEDIUMTEXT，LONGTEXT**；对应的二进制类型是 **TINYBLOB，SMALLBLOB，BLOB，MEDIUMBLOB，LONGBLOB**。**BLOB是SMALLBLOB的同义词**，**TEXT是SMALLTEXT的同义词**。

与其他类型不同，**MYSQL把每个BLOB和TEXT值当作一个独立的对象处理**。存储引擎在存储时通常会做特殊处理。当BLOB和TEXT值太大时，**InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1 ~ 4个字节存储一个指针，然后在外部存储区域存储实际的值**。

BLOB和TEXT 家族之间仅有的不同时 **BLOB类型存储的是二进制数据，没有排序规则或字符集**，而**TEXT类型有字符集和排序规则**。

**MYSQL对BLOB和TEXT列进行排序与其他类型是不同的**：它**只对每个列的最前 max_sort_length字节而不是整个字符串做排序**。如只需要排序前面一小部分字符，则可以减小max_sort_length的配置，或者使用 ORDER BY SUSTRING(column, length)。

**MYSQL不能将 BLOB和TEXT列的全部长度的字符串进行索引**，也**不能使用这些索引消除排序**。(关于这个主题下一章会有更多的信息。)

> 磁盘临时表和文件排序
>
> 因为Memory引擎不支持BLOB和TEXT类型，所以，如果查询使用了BLOB或TEXT列并且需要使用隐式临时表，将不得不使用MyISAM磁盘临时表，即使只有几行数据也是如此（Percona Server 的Memory引擎支持BLOB和TEXT类型，但直到本书写作之际，同样的场景下还是需要使用磁盘临时表）。
>
> 这会导致严重的性能开销。即使配置MYSQL将临时表存储在内存块设备上（RAM Disk），依然需要许多昂贵的系统调用。
>
> 最好的解决方案是尽量避免使用BLOB和TEXT类型。如果实在无法避免，有一个技巧是所有用到BLOB字段的地方都是用SUBSTRING（column, length）将列值转换为字符串（在 ORDER BY 子句中也适用），这样就可以使用内存临时表了。但是要确保截取的字符串足够短，不会使临时表的大小超过 max_heap_table_size 或 tmp_table_size ,朝贡国以后Mysql会将内存临时表转换为MyISAM磁盘临时表。
>
> 最坏情况下的长度分配对于排序的时候也是一样的，所以这一招对于内存中创建大临时表和文件排序，以及在磁盘上创建大临时表和文件排序这两种情况都很有帮助。
>
> 例如，假设有一个1000万行的表，占用几个GB的磁盘空间。其中有一个utf8字符集的VARCHAR（1000）列。每个字符最多使用3个字节，最坏情况下需要3000字节的空间。如果在ORDER BY 中用到这个列，并且查询扫描整个表，为了排序就需要超过30GB的临时表。
>
> 如果EXPLAIN执行计划的Extra列包含“Using temporary”，则说明这个查询使用了隐式临时表。



**使用枚举（ENUM）代替字符串类型**

有时候可以使用枚举列代替常用的字符串类型。枚举列可以把一些不重复的字符串存储成一个预定义的集合。Mysql在**存储枚举时非常紧凑**，会根据列表的数量**压缩到一个或两个字节**中。**Mysql在内部会将每个值在列表中的位置保存成整数**，**并且在表的`.frm`文件中保存“数字-字符串”映射关系的“查找表”**。

**枚举数据实际存储为整形，而不是字符串。**

**枚举字段是按照内部存储的整数而不是定义的字符串进行排序的**。一种绕过这种限制的方式是按照需要的排序来定义枚举列。另外也可以在查询中使用FIELD（）函数显式地指定排序顺序，但这会导致Mysql无法利用索引消除排序。

枚举最不好的地方是，字符串列表是固定的，**添加或删除字符串必须使用ALTER TABLE**。因此，对于一系列未来可能会改变的字符串，使用枚举不是一个好主意，除非能接受旨在列表末尾添加元素，这样在Mysql 5.1中就可以不用重建整个表来完成修改。

由于Mysql把每个枚举值保存为整数，并且必须进行查找才能转换为字符串，所以**枚举列有一些开销**。通常枚举的列表都比较小，所以开销还可以控制，但也不能保证一致如此。在特定情况下，把CHAR/VARCHAR列与枚举列进行关联可能会比直接关联CHAR/VARCHAR列更慢。

详见P120

结论：**ENUM 关联 ENUM 最快，其次  VARCHAR 关联 VARCHAR ，混合关联最差**

然而，转换列为枚举类型还有另一个好处。根据SHOW TABLE STATUS命令输出结果中 Data_length列的值，把这两列转换为ENUM可以让表的大小缩小1/3 。在某些情况下，即使可能出现ENUM 和 VARCHAR进行关联的情况，这也是值得的。同样，转换后主键也只有原来的一半大小了。因为这是InnoDB表，如果表上有其他索引，减小主键大小会使非主键索引也变得更小。稍后再解释这个问题。

### 4.1.4 日期和时间类型

Mysql可以使用许多类型来保存日期和时间值，例如**YEAR和DATE**。MYSQL能存储的最小时间粒度为妙（MariaDB支持微秒级别的时间类型）。但是Mysql也可以使用微秒级别的粒度进行临时运算，我们会展示怎么绕开这种存储限制。

大部分时间类型都没有替代品，因此没有扫描时最佳选择的问题。唯一的问题是保存日期和时间的时候需要做扫描。Mysql提供两种相似的日期类型：**DATETIME和TIMESTAMP**。对于很多应用程序，它们都能工作，但是在某些场景，一个比另一个工作得好。让我们来看一下。

- **DATETIME**

  这个类型能保存**大范围**的值，从**1001年到9999年**，**精度为秒**。它把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，**与时区无关**。使用**8个字节的存储空间**。

  默认情况下，MYSQL以一种可排序的、无歧义的格式显式DATETIME值，例如“2008-01-16 22:37:08”。这是ANSI标准定义的日期和时间表示方法。

- **TIMESTAMP**

  就像它的名字一样，**TIMESTAMP类型保存了从1970年1月1日午夜（格林尼治标准时间）以来的秒数**，他和UNIX时间戳相同。TIMESTAMP只使用**4个字节的存储空间**，因此它的范围比DATETIME小得多：只能表示**从1970年到2038年**。MYSQL提供了FROM_UNIXTIME()函数把Unix时间戳转换为日期，并提供了UNIX_TIMESTAMP()函数把日期转换为Unix时间戳。

  MYSQL 4.1 以及更新的版本按照DATETIME的方式格式化TIMESTAMP的值，但是MYSQL 4.0 以及更老的版本不会在各个部分之间显示任何标点符号。这仅仅是显示格式上的区别，TIMESTAMP的存储格式在各个版本都是一样的。

  TIMESTAMP显示的值也**依赖于时区**。**MYSQL服务器、操作系统，以及客户端连接都有时区设置**。

  因此，存储值为0的TIMESTAMP在美国东部时区显示为"1969-12-31 19:00:00" ，与格林尼治时间差5个小时。有必要强调一下这个区别：如果多个时区存储或访问数据，**TIMESTAMP和DATETIME的行为将很不一样**。**前者提供的值与时区有关系，后者则保留文本表示的日期和时间**。

  TIMESTAMP也有DATETIME没有的特殊属性。默认情况下，如果**插入时没有指定第一个TIMESTAMP列的值，MYSQL则设置这个列的值为当前时间**。在**更新一行记录时，MYSQL默认也会更新第一个TIMESTAMP列的值（除非在UPDATE语句中明确指定了值）**。你可以配置任何TIMESTAMP列的插入和更新行为。最后，**TIMESTAMP列默认为NOT NULL**，这也和其他数据类型不一样。

除了特殊行为之外，通常也**应该尽量使用TIMESTAMP，因为它比DATETIME空间效率更高**。有时候人们会将Unix时间戳存储为整数值，但这不会带来任何收益。用整数保存时间戳的格式通常不方便处理，所以我们不推荐这样做。

如果需要存储比秒更小粒度的日期和时间值怎么办？MYSQL目前没有提供可是的数据类型，但是可以使用自己的存储格式：可以使用BIGINT类型存储微秒级别的时间戳，或者使用DOUBLE存储秒之后的小数部分。这两种方式都可以，或者也可以使用MariaDB代替MySQL。

### 4.1.5 位数据类型

Mysql有少数几种存储类型使用紧凑的位存储数据。所有这些位类型，不管底层存储格式和处理方式如何，从技术上来说都是**字符串类型**。

- **BIT** 

  在MYSQL 5.0 之前，BIT是TINYINT的同义词。但是在MYSQL 5.0 以及更新的版本，这是一个特性完全不同的数据类型。下面我们将讨论BIT类型新的行为特性。

  可以使用**BIT列在一列中存储一个或多个true/false值**。BIT（1）定义一个包含单个位的字段，BIT（2）存储两个位，以此类推。BIT列的最大长度是64个位。

  BIT的行为因存储引擎而异。MyISAM会打包存储所有的BIT列，所以17个单独的BIT列只需要17个位存储（假设没有可为NULL的列），这样MyISAM只使用3个字节就能存储这17个BIT列。其他存储引擎例如Memory和InnoDB，为每个BIT列使用一个足够存储的最小整数类型来存放，所以不能节省空间。

  **MYSQL把BIT当作字符串类型 ，而不是数字类型**。当检索BIT（1）的值时，结果是一个包含二进制 0 或 1 值的字符串，而不是ASCII码的 "0" 或 "1" 。然而，**在数字上下文场景中检索时，结果将是字符串转换成的数字**。如果需要和另外的值比较结果，一定要记得这一点。例如，如果存储一个值b '00111001'（二进制值等于57）到BIT（8）的列并检索他，得到的内容是字符码为57的字符串。也就是说得到ASCII码为57的字符串"9" 。但是在数字上下文场景中，得到的是数字57

  如果想在bit的存储空间中存储一个true/false值，另一个方法是创建一个可以为空的CHAR（0）列。该列可以保存空值（NULL）或者长度为零的字符串（空字符串）。

- **SET**

  如果需要保存很多true/false值，可以考虑合并这些列到一个SET数据类型，他在**MYSQL内部是以一系列打包的位的集合来表示的**。这样就有效地利用了存储空间，并且Mysql有想FIND_IN_SET() 和 FIELD() 这样的函数，方便地在查询中使用。它的**主要缺点**是**改变列的定义的代价较高：需要ALTER TABLE**，这对大表来说是非常昂贵的操作。一般来说，也**无法在SET列上通过索引查找**。

- **在整数列上进行按位操作**

  一种替代SET的方式是使用**一个整数包装一系列的位**。例如，可以把8个位包装到一个TINYINT中，并且按照位操作来使用。可以在应用中为每个位定义名称常量来简化这个工作。

  比起SET，这种办法主要的好处在于可以不适用ALTER TABLE 改变字段代表的“枚举”值，缺点是查询语句更难些，并且更难理解（当第5个bit位被设置时是什么意思？）。一些人非常适应这种方式，也有一些人不适应，所以是否采用这种技术取决于个人的偏好。

详见P124

### 4.1.6 选择标识符（identifier）

**为标识列（identifier column）选择合适的数据类型非常重要**。一般来说更有可能用标识列与其他值进行比较（例如，在关联操作中），或者通过标识列寻找其他列。标识列也可能在另外的表中作为外键使用，所以**为标识列选择数据类型时，应该选择跟关联表中对应列一样的类型（**正如我们在本章早些时候所述的一样，在相关的表中使用相同的数据类型是个好主意，因为这些列很可能在关联中使用）。

当**选择标识列的类型时，不仅仅需要考虑存储类型，还需要考虑Mysql对这种类型怎么执行计算和比较**。例如，**MYSQL在内部使用整数存储ENUM 和SET类型，然后在做比较操作时转换为字符串**。

一旦**选定了一种类型，要确保在所有关联表中都使用同样的类型**。**类型之间需要精确匹配，包括像UNSIGNED这样的属性**。**混用不同数据类型可能导致性能问题**，即使没有性能影响，在**比较操作时隐式类型转换也可能导致很难发现的错误**。这种错误可能会很久以后才突然出现，那时候可能都已经忘记时在比较不同的数据类型。

**在可以满足值的范围的需求，并预留未来增长空间的前提下，应该选择最小的数据类型**。例如有一个state_id列存储美国各州的名字，就不需要几千或几百万个值，所以不需要使用INT。TINYINT足够存储，而且比INT少了3个字节。如果用这个值作为其他表的外键，3个字节可能导致很大的性能差异。下面时一些小技巧。

- **整数类型**

  **整数通常时标识列最好的选择，因为它们很快并且可以使用 AUTO_INCREMENT。**

- **ENUM 和 SET 类型**

  **对于标识列来说， ENUM 和 SET 类型通常时一个糟糕的选择**，尽管对某些列只包含固定状态或者类型的静态“定义表”来说可能是没有问题的。**ENUM 和 SET列适合存储固定信息**，例如有序的状态、产品类型、人的性别。

  举个例子，如果使用枚举字段来定义产品类型，也许会设计一张以这个枚举字段为主键的查找表（可以在查找表中增加一些列来保存描述性质的文本，这样就能够生成一个术语表，或者为网站的下拉菜单提供有意义的标签）。这是，使用枚举类型作为标识列是可行的，但大部分情况下都要避免这么做。

- **字符串类型**

  如果可能，**应该避免使用字符串类型作为标识列**，因为它们**很消耗空间**，并且**通常比数字类型慢**。尤其是在MyISAM表里使用字符串作为标识列时要特别小心。MyISAM默认对字符串使用压缩索引，这会导致查询慢得多。在我们的测试中，我们注意到最多有6倍的性能下降。

  **对于完全“随机“的字符串也需要多加注意**，利于MD5()、SHA1() 或者 UUID() 产生的字符串。这些函数生成的新值会任意分布在很大的空间内，这会导致INSERT以及一些SELECT语句变得很慢：

  - 因为**插入值会随机的写到索引的不同位置**，所以使得INSERT语句更慢。这回导致**页分裂**，**磁盘随机访问**，以及对于**聚簇存储引擎产生聚簇索引碎片**。关于这一点第5章有更多的讨论。
  - **SELECT语句会变得更慢**，因为**逻辑上相邻的行会分布在磁盘和内存的不同地方**。
  - **随机值导致缓存对所有类型的查询语句效果都很差**，因为会使得缓存赖以工作的访问局部性原理失效。如果整个数据集都一样的”热“，那么缓存任何一部分特定数据到内存都没有好处；如果工作集比内存大，缓存将会有很多刷新和不命中。

  如果存储UUID，则应该移除”-“符号；或者更好的做法是，用UNHEX()函数转换UUID为16字节的数字，并且存储在一个BINARY（16）列中。检索时可以通过HEX() 函数来格式化为十六进制格式。

  UUID() 生成的值与加密散列函数例如SHA1() 生成的值有不同的特征：UUID值虽然分布也不均匀，但还是有一定顺序的。尽管如此，但还是不如递增的整数好用。

### 4.1.7 特殊类型数据

某些类型的数据并不直接与内置类型一致。低于秒级精度的时间戳就是一个例子；本章的前面部分也演示过存储此类数据的一些选项。

另一个例子时一个IPv4地址。人们经常使用VARCHAR（15）列来存储IP地址。然而，他们实际上时32位无符号整数，不是字符串。用小数点将地址分成四段的标识方法只是为了让人们阅读容易。所以应该用无符号整数存储IP地址。MYSQL提供INET_ATON() 和 INET_NTOA() 函数在两种表示方法之间转换。

## 4.2 MYSQL schema 设计中的陷阱

虽然有一些普遍的好或坏的设计原则，但也有一些问题是由MYSQL的实现机制导致的，这意味着有可能犯一些只在MYSQL下发生的特定错误。

- **太多的列**

  **MYSQL的存储引擎API工作时需要在服务器和存储引擎之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列**。**从行缓冲中将编码的列转换成行数据结构的操作代价时非常高的**。MyISAM的定长行结构和InnoDB的行结构则总是需要转换。转换的代价依赖与列的数量。

  如果计划使用数千个字段，必须意识到服务器的性能运行特征会有一些不同。

- **太多的关联**

  所谓的“实体-属性-值”（EAV）设计模式是一个常见的糟糕设计模式，尤其是在Mysql下面不能靠谱地工作。**Mysql限制了每个关联操作最多只能有61张表**，但是EAV数据库需要许多自关联。我们讲过不少EAV数据库最后超过了这个限制。事实上在许多关联少于61张表的情况下，**解析和优化查询的代价也会成为Mysql的问题**。**一个粗略的经验法则，如果希望查询执行得快速且并发性好，单个查询最好在12个表以内做关联**。

- **全能的枚举**

  注意防止过度的使用枚举（ENUM）。

- **变相的枚举**

  枚举列允许在列中存储一组定义值中的单个值，集合（SET）列则允许在列中存储一组定义值中的一个或多个值。

- **非此发明（Not Invent Here）的NULL**

  我们之前写了避免使用NULL的好处，并建议尽可能地考虑替代方案。即使需要存储一个事实上的“空值”到表中时，也不一定非得使用NULL。也许可以使用0、某个特殊值，或者空字符串作为代替。

  但**遵循这个原则也不要走极端**。当确实需要表示未知值时也不要害怕使用NULL，在一些场景中，使用NULL可能会比某个神奇常数更好。从特定类型的值域中选择一个不可能的值，例如用-1代表一个位置整数，可能会导致代码复杂很多，并且容易引入bug，可能会让事情变得一团糟。处理NULL确实不容易，但有时候会比它的替代方案更好。

## 4.3 范式和反范式

对于任何给定的数据通常都有很多中表示方法，从完全的范式化到完全的反范式化，以及两者的折中。在范式化的数据库中，每个事实数据会出现并且只出现一次。相反，在反范式化的数据库中，信息是冗余的，可能会存储在多个地方。

例子详见P129

### 4.3.1 范式的优点和缺点

当为性能问题而寻求帮助时，经常会被建议对schema进行范式化设计，尤其是写密集的场景。

- **范式化的更新操作通常比反范式化要快**
- 当数据**较好的范式化时**，就**只有很少或者没有重复数据**，所以**只需要修改更少的数据**。
- **范式化的表通常更小**，**可以更好地放在内存里**，所以**执行操作会更快**。
- 很少有多余的数据意味着检索列表数据时**更少需要DISTINCT 或者 GROUP BY 语句**。还是前面的例子：在非范式化的结构中必须使用DISTINCT或者GROUP BY才能获得一份唯一的部门列表，但时如果部门（DEPARTMENT）时一张当都的表，则只需要简单的查询这张表就行了。

范式化设计的schema的缺点是**通常需要关联**。稍微复杂一些的查询语句在符合范式的schema上都可能需要至少一次关联，也许更多。这不但**代价昂贵**，也**可能使一些索引策略无效**。例如，范式化可能将列存放在不同的表中，而这些列如果在一个表中本可以属于同一个索引。

### 4.3.2 反范式的优点和缺点

**反范式化的schema因为所有数据都在一张表中，可以很好地避免关联。**

如果不需要关联表，则对大部分查询最差的情况——即使没有使用索引——使全表扫描。当**数据比内存大时这可能比关联要快的多，因为这样避免了随机I/O**。

详见P130

### 4.3.3 混用范式化和反范式化

在实际应用中经常需要混用，可能使用部分范式化的schema、缓存表，以及其他技巧。

**最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列**。在MySQL 5.0 和更新版本中，可以使用触发器更新缓存数据，这使得实现这样的方案变得更简单。

缓存衍生值也是有用的。如果需要显示每个用户发了多少消息（像很多论坛做的），可以每次执行一个昂贵的子查询来计算并显示它；也可以在user表中建一个num_messages 列，每当用户发新消息时更新这个值。

## 4.4 缓存表和汇总表

有时候提升性能最好的方法时**在同一张表中保存衍生的冗余数据**。然而，有时，也需要**创建一张完全独立的汇总表或缓存表（特别是为满足检索的需求时）**。如果能容许少量的脏数据，这是非常好的方法，但是有时确实没有选择的余地（例如，需要避免复杂、昂贵的实时更新操作）。

术语“缓存表”和“汇总表”没有标准的含义。我们用术语**”缓存表“来表示存储那些可以比较简单地从schema其他表获取（但是每次获取的速度比较慢）数据的表（例如，逻辑上冗余的数据）**。而术语**”汇总表“时，则保存的时使用GROUP BY语句聚合数据的表（例如，数据不是逻辑上冗余的）**。也有人使用术语”累积表（Roll-Up Table）“称呼这些表，因为这些数据被”累积“了。

详见P132

缓存表则相反，其对优化搜索和检索查询语句很有效。这些查询语句经常需要特殊的表和索引结构，跟普通OLTP操作用的表有些区别。

例如，可能会**需要很多不同的索引组合来加速各种类型的查询**。这些矛盾的需求有时需要创建一张只包含主表中部分列的缓存表。一个有用的技巧是**对缓存表使用不同的存储引擎**。例如，如果主表使用InnoDB，用MyISAM作为缓存表的引擎将会得到更小的索引占用空间，并且可以做全文搜索。有时甚至想把整个表导出Mysql，插入到专门的搜索系统中获得更高的搜索效率，例如 Lucene 或者 Sphinx 搜索引擎。

在使用缓存表和汇总表时，**必须决定是维护数据还是定期重建**。哪个更好依赖于应用程序，但是**定期重建并不只是节省资源，也可以保持表不会有很多碎片，以及有完全顺序组织的索引（这会更加高效）**。

详见 P133

### 4.4.1 物化视图

**物化视图实际上是预先计算并且存储在磁盘上的表**，可以通过各种各样的策略刷新和更新。**MYSQL并不原生支持物化视图**。然而，使用Justin Swanhart 的开源工具Flexviews，也可以自己实现物化视图。Flexviews比完全自己实现的解决方案要更精细，并且提供了很多不错的功能使得可以更简单地创建和维护物化视图。它由下面这些部分组成：

- 变更数据抓取（Change Data Capture，CDC）功能，可以读取服务器的二进制日志并且解析相关行的变更。
- 一系列可以帮助创建和管理视图的定义的存储过程。
- 一些可以应用变更到数据库中的物化视图的工具。

详见P134

### 4.4.2 计数器表

如果应用在表中保存计数器，则在更新计数器时可能碰到并发问题。计数器表在Web应用中很常见。可以用这种表缓存一个用户的朋友数、文件下载次数等。创建一张独立的表存储计数器通常是个好主意，这样可使计数器表小且快。使用独立的表可以帮助避免查询缓存失效，并且可以使用本节展示的一些高级技巧。

详见P135

## 4.5 加快ALTER TABLE 操作的速度

Mysql的ALTER TABLE操作的性能对大表来说是个大问题。MySQL执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新标，然后删除旧表。这样操作可能需要花费很长时间，如果内存不足而表又很大，而且还有很多索引的情况下尤其如此。许多人都有这样的经验，ALTER TABLE操作需要花费数个小时甚至数天才能完成。

对于常见的场景，能使用的技巧只有两种：**一种是现在一台不提供服务的机器上执行ALTER TABLE操作，然后和提供服务的主库进行切换**；**另一种机巧是”影子拷贝“。影子拷贝的技巧是用要求的表结构创建一张和源表无关的信标，然后通过重命名和删表操作交换两张表**。

不是所有的ALTER TABLE操作都会引起表重建。例如，又两种方法可以改变或者删除一个列的默认值（一种方法很快，另一种则很慢）。

详见P137

### 4.5.1 只修改.frm 文件

从上面的例子我们看到修改表的.frm文件是很快的，但MYSQL有时候会在没有必要的时候也重建表。如果愿意冒一些风险，可以让MySQL做一些其他类型的修改而不用重建表。

下面这些操作是可能不需要重建表的：

- 移除（不是增加）一个列的AUTO_INCREMENT 属性。
- 增加、移除，或更改ENUM 和 SET常量。如果移除的是已经有行数据用到其值的常量，查询将会返回一个空字符串值。

**基本的技术是为想要的表结构创建一个新的.frm文件，然后用它替换掉已经存在的那张表的.frm 文件**，像下面这样：

1. 创建一张有相同结构的空表，并进行所需要的修改（例如增加ENUM常量）
2. 执行 FLUSH TABLES WITH READ LOCK。这将会关闭所有正在使用的表，并且禁止任何表被打开。
3. 交换.frm 文件
4. 执行UNLOCK TABLES 来释放第2步的读锁。



**注意， 我们是在常量列表的末尾增加一个新的值。如果把新增的值放在中间，则会导致已经存在的数据的含义被改变。**



### 4.5.2 快速创建MyISAM索引

为了**高效的载入数据到MyISAM表中**，有一个常用的技巧是先**禁用索引**、**载入数据**，然后**重新启用索引**。

这个技巧能够发挥作用，是因为**构建索引的工作被延迟到数据完全载入以后**，这个时候已经可以通过排序来构建索引了。这样做会快很多，并且使得索引树的碎片更少，更紧凑。

不幸的是，**这个办法对唯一索引无效**，因为DISABLE KEYS只对非唯一索引有效。**MyISAM会在内存中构造唯一索引，并为载入的每一行检查唯一性。一旦索引的大小超过了有效内存大小，载入操作就会变的越来越慢。**

在现代版本的**InnoDB版本**中，有一个类似的技巧，这**依赖于InnoDB的快速在线索引创建功能**。这个技巧是，**先删除所有的非唯一索引，然后增加新的列，最后重新创建删除掉的索引。**

也可以使用像前面说的 ALTER TABLE 的骇客方法来加速这个操作，但需要多做一些工作并且承担一定的风险。这对从备份中载入数据是很有用的，例如，当已经知道所有数据都是有效的并且没有必要做唯一性检查时就可以这么来操作。

下面是操作步骤：

1. 用需要的表结构创建一张表，但是不包括索引。
2. 载入数据到表中以构建.MYD文件。
3. 按照需要的结构创建另外一张空表，这次要包含索引。这会创建需要的.frm 和 .MYI文件。
4. 获取读锁并刷新表。
5. 重命名第二张表的 .frm 和 .MYI 文件，让MYSQL认为是第一张表的文件。
6. 释放读锁。
7. 使用REPAIR TABLE来重建表的索引。该操作会通过排序来构建所有索引，包括唯一索引。

这个操作步骤对大表来说会快很多。

