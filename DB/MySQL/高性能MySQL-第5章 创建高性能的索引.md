# 第5章 创建高性能的索引

索引是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能，除此之外，本章还将讨论索引的其他一些方面有用的属性。

索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但当数据量主键增大时，性能会急剧下降。

## 5.1 索引基础

在MySQL中，存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。

```sql
SELECT first_name FROM sakila.actor WHERE actor_id = 5;
```

如果在actor_id列上建有索引，则MYSQL将使用该索引找到actor_id 为5 的行，也就是说，MYSQL现在索引上按值进行查找，然后返回所有包含该值的数据行。

索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为MYSQL只能高效的使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引时大不相同的。

### 5.1.1 索引的类型

索引有很多种类型，可以为不同的场景提供更好的性能。在MYSQL中，索引时在存储引擎层而不是服务器层实现的。所以，没有同一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。

- B-Tree 索引

  当人们谈论索引的时候，如果没有特别指明类型，那多半说的是B-Tree索引，它使用B-Tree数据结构来存储数据。大多数Mysql引擎都支持这种索引。Archive引擎是一个例外：5.1 之前Archive不支持任何索引，直到5.1 才开始支持单个自增列（AUTO_INCREMENT）的索引。

  我们使用术语“B-Tree”，是因为Mysql在CREATE TABLE和其他语句中也使用该关键字。不过，底层的存储引擎也可能使用不同的存储结构，例如，NDB集群存储引擎内部实际上使用了T-Tree 结构存储这种索引，即使其名字是BTREE ;InnoDB则使用的是B+Tree,各种数据结构和算法的变种不在本书的讨论范围内。

  存储引擎以不同的方式使用B-Tree索引，性能也各有不同，各有优劣。例如，MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储。再如MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。

  B-Tree 通常意味着所有的值都是按照顺序存储的，并且每一个叶子页到根的距离相同。

  详见 P143

  叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页（不同引擎的“指针”类型不同）。

  B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据。

  **可以使用B-Tree索引的查询类型**。B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。前面所述的索引对如下类型的查询有效。

  - 全值匹配

    全值匹配指的是和索引中的所有列进行匹配。

  - 匹配最左前缀

    前面提到的索引可用于查找所有姓为Allen的人，即只使用索引的第一列。

  - 匹配列前缀

    也可以值匹配某一列的值的开头部分。例如前面提到的索引可用于查找所有J开头的姓的人。这里也只使用了索引的第一列。

  - 匹配范围值

    例如前面提到的索引可用于查找姓在Allen和Barrymore之间的人。

  - 精确匹配某一列并范围匹配另外一列

    前面提到的索引也可以用于查找所有姓为Allen，并且名字是字母K开头（比如Kim、Karl等）的人。即第一列last_name全匹配，第二列first_name范围匹配。

  - 只访问索引的查询

    B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无需访问数据行。后面我们将单独讨论这种覆盖索引的优化。

  因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY操作（按顺序查找）。一般来说，如果B-Tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以，如果ORDER BY子句满足前面列出的集中查询类型，则这个索引也可以满足对饮的排序需求。

  下面是一些关于B-Tree索引的限制：

  - 如果不是按照索引的最左列开始查找，则无法使用索引。
  - 不能跳过索引中的列。
  - 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找

- 哈希索引

  哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码。哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存每个数据行的指针。

  在Mysql中，只有Memory引擎显示支持哈希索引。这也是Memory引擎表的默认索引类型，Memory引擎同时也支持B-Tree索引。值得一提的是，Memory引擎是支持非唯一哈希索引的，这在数据库世界里面是比较与众不同的。如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。

  详见 P147

  因为索引自身只包含哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。然而哈希索引也有它的限制：

  - 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。
  - 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。
  - 哈希索引页不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。
  - 哈希索引支支持等值比较，包括=、IN()、<=> （注意<> 和<=>是不同的操作）。也不支持任何范围查询，例如WHERE price > 100。
  - 访问哈希索引的数据非常快，除非有很多哈希冲突（不同的索引值却却相同的哈希值）。当出现哈希冲突的时候，存储引擎必须便利链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。
  - 如果哈希冲突很多的话，一些索引维护操作的代价也会很高。例如，如果在某个选择性很低（哈希冲突很多）的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对于哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。

  因为这些限制，哈希索引只适用于某些特定的场合。而一旦适应哈希索引，则它带来的性能提升将非常显著。举个例子，在数据仓库应用中有一种经典的”新型“schema，需要关联很多查找表，哈希索引就非常适合查找表的需求。

  InnoDB引擎 有一个特殊的功能叫做”自适应哈希索引“。当InnoDB注意到某些索引值被使用地非常频繁时，他会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引页具有哈希索引的一些有点，比如快速的哈希查找。这是一个完全自动、内部的行为，用户无法控制或者配置，不过如果有必要，完全可以关闭该功能。

  **创建自定义哈希索引**。如果存储引擎不支持哈希索引，则可以模拟像InnoDB一样创建哈希索引，这可以享受一些哈希索引的便利，例如只需要很小的索引就可以为超长的键创建索引。

  思路很简单：再B-Tree基础上创建一个伪哈希索引。这和真正的哈希索引不是一回事，因为还是使用B-Tree进行查找，但是它使用哈希值而不是键本身进行索引查找。你需要做的就是再查询的WHERE子句中手动执行使用哈希函数。

  实例见P148

  要避免冲突问题，必须再WHERE条件中带入哈希值和对应列值。如果不是像查询具体值，例如只是统计记录数（不精确的），则可以不带入列值，直接使用CRC32（） 的哈希值查询即可。还可以使用如FNV64（）函数作为哈希函数，这是移植自Percona Server的函数，可以以插件的方式再任何Mysql版本中使用，哈希值为64位，速度快，且冲突比CRC32（） 要少很多

- 空间数据索引（R-Tree）

  MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无需前缀查询。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。必须使用Mysql的GIS相关函数如MBRCONTAINS() 等来维护数据。MySQL的GIS支持并不完善，所以大部分人都不会使用这个特性。开源关系数据库系统中对GIS的解决方案做的比较好的时PostgreSQL的PostGIS。

- 全文索引

  全文索引时一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。全文搜索和其他集中索引的匹配方式完全不一样。他又许多需要注意的细节，如停用词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事情，而不是简单的WHERE 条件匹配。

  再相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于 MATHCH AGAINST操作，而不是普通的 WHERE 条件操作。

- 其他索引类别。

  还有很多第三方的存储引擎使用不同类型的数据结构来存储索引。例如TokuDB使用分形树索引（fractal tree index），这是一类较新开发的数据结构，既有B-Tree的很多优点，页避免了B-Tree的一些缺点。ScaleDB使用Patricia tries（这个词不是拼写错误）。其他一些存储引擎技术如InfiniDB和Infobright则使用了一些特殊的数据结构来与欧化某些特殊的查询。

## 5.2 索引的优点

索引可以让服务器快速地定位到表的指定位置。但是这并不是索引的唯一作用，到目前为止可以看到，根据创建索引的数据结构不同，索引也有一些其他的附加作用。

最常见的B-Tree索引，按照顺序存储数据，所以Mysql 也可以用来做ORDER BY 和 GROUP BY操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储再一起。最后，因为索引中存储了实际的列值，所以某些查询只是用索引就能够完成全部查询。据此特性，总结下来索引有如下三个优点：

1. 索引大大减少了服务器需要扫描的数据量。
2. 索引可以帮助服务器避免排序和临时表。
3. 索引可以将随机I/O变为顺序I/O。



## 5.3 高性能的索引策略

高效的选择和使用索引有很多种方式，其中有些是针对特殊案例的优化方法，有些则是针对特定行为的优化。使用哪种索引，以及如何评估选择不同索引的性能影响的技巧，则需要不断的学习。

### 5.3.1 独立的列

我们通常会看到一些查询不当地使用索引，或者使得Mysql无法使用已有的索引。如果查询中的列不是独立的，则MySQL就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。

例如，下面这个查询无法使用actor_id列的索引：

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

凭肉眼很容易看出WHERE中的表达式其实等价于actor_id = 4，但是MySQL无法自动解析这个方程式。这完全是用户行为。我们应该养成简化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧。

下面是一个另一个常见的错误：

```sql
SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
```

### 5.3.2 前缀索引和索引选择性

有时候需要索引很长的字符串，这会让索引变得大且慢。一个策略是前面提到过的模拟哈希索引。但有时候这样做还不够，还可以做些什么呢？

通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。选择性是指，不重复的索引值（也称为基数，cardinality）和数据表的记录总数（#T）的比值，范围从1/#T 到 1 之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL再查找是过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能。对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MYSQL不允许索引这些列的完整长度。

诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。前缀应该足够长，使得前缀索引的选择性接近于索引整个列。换句话说，前缀的“基数”应该接近于完整列的“基数”。

如何决定前缀合适的长度 详见P154



前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点：MYSQL无法使用前缀索引做ORDER BY 和GROUP BY，也无法使用前缀索引做覆盖扫描。



### 5.3.3 多列索引

一个常见的错误就是，为每列创建独立的索引，或者按照错误的顺序创建多列索引。

再多个列上建立独立的单列索引大部分情况下并不能提高Mysql的查询性能。Mysql5.0 和更新版本引入了一种叫“索引合并”（index merge）的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。更早版本的MySQL只能使用其中某一个单列索引，然而这种情况下没有哪一个独立的单例索引是非常有效的。

索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引列建的很糟糕：

- 当出现服务器对多个索引列做相交操作时（通常有多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。
- 当服务器需要对多个索引做联合操作时（通常有多个OR条件），通常需要消耗大量CPU和内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。
- 更重要的时，优化器不会把这些计算到“查询成本”（cost）中，优化器指关心随即页面读取。这回使得查询的成本被“低估”，导致该执行计划还不如直接走全表扫描。这样做不但会消耗更多的CPU和内存资源，还可能会影响查询的并发性，但如果是单独运行这样的查询则往往会忽略对并发性的影响。通常来说，还不如像在MYSQL 4.1 或者更早的时代一样，将查询改成UNION的方式往往更好。

### 5.3.4 选择合适的索引列顺序

我们遇到的最容易引起困惑的问题就是索引列的顺序。正确的顺序依赖于使用该索引的查询，并同时需要考虑如何更好的满足排序和分组的需要。

在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等，所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等子句的查询需求。

对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列。这个建议有用吗？在某些场景可能有帮助，但通常不如避免随机IO和排序那么重要，考虑问题需要更全面（场景不同则选择不同，没有一个放之四海皆准的法则。这里只是说明，这个经验法则可能没有你想象的重要。）

当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这时候索引的作用只是用于优化WHERE条件的查找。这种情况下，这样设计的索引确实能够最快的过滤出需要的行，对于在WHERE子句中只是用了索引部分前缀列的查询来说选择性也更高。然而，性能不指依赖于所有索引列的选择性（整体基数），也和查询条件的具体值有关，也就是和值的分布有关。这和前面介绍的选择前缀的长度需要考虑的地方一样。可能需要根据哪些运行频率最高的查询来调整索引列的顺序，让这种情况下索引的选择性最高。

### 5.3.5 聚簇索引

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式，具体的细节依赖于其实现方式，但InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。

当标有聚簇索引时，它的数据行实际上存放在索引的叶子页中。术语“聚簇”表示数据行和相邻的键值紧凑的存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引（不过，覆盖索引可以模拟多个聚簇索引的情况，本章后面将详细介绍）。

因为是存储引擎负责实现索引，因此不是所有的存储引擎都支持聚簇索引。本节我们主要关注InnoDB，但是这里讨论的原理对于任何支持聚簇索引的存储引擎都是使用的。

一些数据库服务器允许选择哪个索引作为聚簇索引，但直到本书写作之际，还没有任何一个Mysql内建的存储引擎支持这一点。InnoDB将通过主键聚集数据，也就是说图中的“被索引的列”就是主键列。

如果没有定义主键，InnoDB会选择一个唯一的非空索引来代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。**InnoDB只聚集在同一个页面中的记录。包含相邻键值的页面可能会相距甚远。**

聚簇主键可能对性能有帮助，但也可能导致严重的性能问题。所以需要仔细地考虑聚簇索引，尤其是将表的存储引擎从InnoDB改成其他引擎的时候（反过来也一样）。

聚簇的数据有一些重要的优点：

- 可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户Id来聚集数据，这样只需要从磁盘读取少量的数据页就能获得某个 用户的全部邮件。如果没有使用聚簇索引，则每封电子邮件都可能导致一次磁盘I/O。
- 数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。
- 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

如果在设计表和查询时能充分利用上面的优点，那就能极大地提升性能。同时，聚簇索引也有一些缺点：

- 聚簇数据最大限度的提高了I/O密集型应用的性能，但如果数据全部都放在内存中。则访问的顺序就每那么重要了，聚簇索引也没扫描优势了。
- 插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成之后最好使用OPTIMIZE TABLE 命令重新组织一下表。
- 更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。
- 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动时，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已经满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。
- 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。
- 二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。
- 二级索引访问需要两次索引查找，而不是一次。

二级索引中保存的“行指针”。要记住，二级索引叶子节点保存的不是只想行的物理位置的指针、而是行的主键值。这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。这里做了重复的工作：两次B-Tree查找而不是一次。对于InnoDB，自适应哈希索引能够减少这样重复的工作。

**InnoDB和MyISAM的数据分布对比**

聚簇索引和非聚簇索引的数据分布有区别，以及对应的主键索引和二级索引的数据分布也有区别，通常会让人感到困惑和意外。

详见 P164

**在InnoDB表中按主键顺序插入行**

如果正在使用InnoDB表并且没有扫描数据需要聚集，那么可以定义一个代理键作为主键，这种主键的数据应该和应用无关，最简单的方法时使用 AUTO_INCREMENT 自增列。这样可以保证数据行是按顺序写入，对于根据主键做关联操作的性能也会更好。

最好避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于I/O 密集型的应用。例如，从性能的角度考虑，使用UUID来作为聚簇索引则会很糟糕：它使得聚簇索引的插入变得完全随机，这是最坏的情况，使得数据没有任何聚集特性。

演示验证见 P168

UUID主键插入行不仅花费的时间更长，而且索引占用的空间页更大。这一方面是由于主键字段更长；另一方面毫无疑问是由于页分裂和碎片导致的。

- 自增主键

  因为主键的值是顺序的，所以InnoDB把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB默认的最大填充因子时页大小的15/16，留出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满，这也正是所期望的结果（然而，二级索引页可能是不一样的）。

- UUID主键

  因为新行的主键值不一定比之前插入的大，所以InnoDB无法简单地总是把新行插入到索引的最后，而是需要为新的行寻找合适的位置——通常是已有数据的中间位置——并且分配空间。这会增加很多的额外工作，并导致数据分布不够优化。下面是总结的一些缺点：

  - 写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘中读取目标页到内存中。这将导致大量的随机I/O。
  - 因为写入时乱序的，InnoDB不得不频繁地做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。
  - 由于频繁的页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有碎片。
  - 把这些随机值载入到聚簇索引以后，也许需要做一次OPTIMIZE TABLE 来重建表并优化页的填充。

> 顺序的主键什么时候会造成更坏的结果？
>
> 对于高并发工作负载，在InnoDB中按主键顺序插入可能会造成明显的争用。主键的上界会成为”热点“。因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点可能是AUTO_INCREMENT 锁机制；如果遇到这个问题，则可能需要考虑重新设计表或者应用，或者更改Innodb__autoinc_lock_mode 配置。如果你的服务器版本还不支持 Innodb_autoinc_lock_mode 参数，可以升级到新版本的InnoDB，可能对这种场景工作得更好。

### 5.3.6 覆盖索引

通常大家都会根据查询的WHERE条件来创建合适的索引，不过这只是索引优化的一个方面。设计优秀的索引应该考虑到整个查询，而不单单时WHERE条件部分。索引确实是一种查找数据的高效方式，但是MYSQL页可以使用索引来直接获取列的数据，这样就不再需要读取数据行。如果索引的叶子节点中已经包含要查询的数据，那么还有扫描必要再徽标查询呢？如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为”覆盖索引“。

覆盖索引是非常有用的工具，能够极大地提高性能。考虑一下如果查询只需要扫描索引而无需回表，会带来多少好处：

- 索引条目通常远小于数据行大小，所以如果只需要读取索引，那MYSQL就会极大地减少数据访问量。这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对于I/O密集型的应用也有帮助，因为索引比数据更小，更容易全部放入内存中（这对于MyISAM尤其正确，因为MyISAM能压缩索引以变得更小）。
- 因为索引是按照列值顺序存储的（至少在单个页内是如此），所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少得多。对于某些存储引擎，例如MyISAM和Percona XtraDB，甚至可以通过OPTIMIZE 命令使得索引完全顺序排列，这让简单的范围查询能使用完全的索引访问。
- 一些存储引擎如MyISAM在内存中值缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。这可能会导致严重的性能问题，尤其是哪些系统调用占了数据访问中的最大开销的场景。
- 由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。

不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引。另外，不同的存储引擎实现覆盖索引的方式页不同，而却不是所有的存储引擎都支持覆盖索引（在写作本书时，Memory存储引擎就不支持覆盖索引）。

详细实例见 P172

在大多数存储引擎中，覆盖索引只能覆盖哪些值访问索引中部分列的查询。不过可以更进一步优化InnoDB。回想一下，InnoDB的二级索引的叶子节点都包含了主键的值，这意味着InnoDB的二级索引可以有效地利用这些”额外“的主键列来覆盖查询。

### 5.3.7 使用索引扫描来做排序

Mysql有两种方式可以生成有序的结果：通过排序操作；或者按索引顺序扫描； 如果EXPLAIN出来的type列为“index”，则说明MYSQL使用了索引扫描来做排序（不要和Extra列的“Using index”搞混淆了）。

扫描索引本身时很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢，尤其是在I/O密集型的工作负载时。

MySQL可以使用同一个索引既满足排序，又用于查找行。因此，如果可能，设计索引时应该尽可能地同时满足这两种任务，这样是最好的。

只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求；否则，MYSQL都需要执行排序操作，而无法利用索引排序。

有一种情况下ORDER BY子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果WHERE子句或者JOIN子句中对这些列指定了常量，就可以“弥补”索引的不足。

详细示例讲解见 P176

### 5.3.8 压缩（前缀压缩）索引

MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大地提高性能。默认值压缩字符串，但通过参数设置也可以对整数做压缩。

MyISAM 压缩每个索引块的方法是，先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，把这会部分存储起来即可。例如，索引块的第一个值是“perform”，第二个值是“performance”，那么第二个值的前缀压缩后存储的是类似“7，ance”这样的形式。MyISAM对行指针也采用类似的前缀压缩方式。

压缩块使用更少的空间，代价是某些操作可能更慢。因为每个值的压缩前缀都依赖前面的值，所以MyISAM查找时无法在索引块使用二分查找而只能从头开始扫描。正序的扫描速度还不错，但是如果是倒叙扫描——例如ORDER BY DESC——就不是很好了。所有在块中查找某一行的操作平均都需要扫描半个索引块。

测试表明，对于CPU密集应用，因为扫描需要随机查找，压缩索引使得MyISAM在索引查找上要慢好几倍。压缩索引的倒序扫描就更慢了。压缩索引需要在CPU内存资源与磁盘之间做权衡。压缩索引可能只需要十分之一大小的磁盘空间，如果是I/O密集型应用，对某些查询带来的好处会比成本多很多。

可以在CREATE TABLE 语句中指定PACK_KEYS 参数来控制索引压缩的方式。

### 5.3.9 冗余和重复索引

MySQL允许在相同列上创建多个索引，无论是有意的还是无意的。MySQL需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个的进行考虑，这会影响性能。

重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免这样创建重复索引，发现以后也应该立即移除。

冗余索引和重复索引有一些不同。如果创建了索引（A, B），再创建索引（A）就是冗余索引，因为这只是前一个索引的前缀索引。因此索引（A，B）也可以当作索引（A）来使用（这种冗余只是对B-Tree 索引来说的）。但如果在创建索引（B，A），则不是冗余索引，索引（B）也不是，因为B不是索引（A，B）的最左前缀列。另外，其他不同类型的索引（例如哈希索引或者全文索引）也不会是B-Tree索引的冗余索引，而无论覆盖的索引列是扫描。

详见 P179

>NOTE：
>
>在决定哪些索引可以被删除的时候要非常小心。回忆一下，在前面的InnoDB的示例表中，因为二级索引的叶子节点包含了主键值，所以在列（A）上的索引就相当于在（A，ID）上的索引。如果有像WHERE A = 5 ORDER BY ID 这样的查询，这个索引会很有作用。但如果将索引扩展为（A, B）则实际上就变成了（A,B,ID），那么上面查询的ORDER BY子句就无法使用该索引做排序，而只能用文件排序了。所以，建议使用Percona 工具箱中的pt-upgrade工具来仔细检查计划中的索引变更。

### 5.3.10  未使用的索引

除了冗余索引和重复索引，可能还会有一些服务器永远不用的索引。这样的索引完全是累赘，建议考虑删除。有两个工具可以帮助定位未使用的索引。最简单有效的办法是在Percona Server 或者Maria DB中先打开userstates 服务器变量（默认是关闭的），然后让服务器正常运行一段时间，再通过查询INFORMATION_SCHEMA.INDEX_STATISTICS就能查到每个索引的使用频率。

### 5.3.11 索引和锁

索引可以让查询锁定更少的行。如果你的查询从不访问那些不需要的行，那么就会锁定更少的行，从两个方面来看这对性能都有好处。首先，虽然InnoDB的行锁效率很高，内存使用也很少，但是锁定行的时候任然会带来额外开销；其次，锁定超过需要的行会增加锁争用并减少并发性。

InnoDB只有再访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。但这只有当InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在InnoDB检索到数据并返回给服务器层以后，MySQL服务器才能应用WHERE子句。这时已经无法避免锁定行了：InnoDB已经锁住了这些行，到适当的时候才释放。在MySQL 5.1 和更新的版本中，InnoDB可以在服务器端过滤掉行后就释放锁，但是在早期的MySQL版本中，InnoDB只有在事务提交后才能释放锁。

示例详见 P181

即使使用了索引，InnoDB也可能锁住一些不需要的数据。如果不能使用索引查找和锁定行的话问题可能会更糟糕，MySQL会做全表扫描并锁住所有的行，而不管是不是需要。

关于InnoDB、索引和锁有一些很少有人知道的细节：InnoDB在二级索引上使用共享（读）锁，但在访问主键索引需要排他（写）锁。这消除了使用覆盖索引的可能性，并且使得`SELECT FROM UPDATE` 比 `LOCK IN SHARE MODE`或非锁定查询要慢很多。

## 5.4 索引案例学习

详见P183 **复习必看**

## 5.5 维护索引和表

即使用正确的类型创建了表并加上了合适的索引，工作也没有结束：还需要维护表盒索引来确保它们都正常工作。维护表有三个主要的目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。

### 5.5.1 找到并修复损坏的表

表损坏（corruption）是很糟糕的事情。对于MyISAM存储引擎，表损坏通常是系统崩溃导致的。其他的引擎也会由于硬件问题、MySQL本身的缺陷或者操作系统的问题导致索引损坏。

损坏的索引会导致查询返回错误的结果或者莫须有的主键冲突等问题，严重时甚至还会导致数据库的崩溃。如果你遇到了古怪的问题——例如一些不应该发生的错误——可以尝试运行CHECK TABLE来检查是否发生了表损坏（注意有些存储引擎不支持该命令；而有些引擎则支持以不同的选项来控制完全检查表的方式）。CHECK TABLE通常能够找出大多数表和索引的错误。

可以使用REPAIR TABLE命令来修复损坏的表，但同样不是所有的存储引擎都支持该命令。如果存储引擎不支持，也可以通过一个不做任何操作（no-op）的ALTER操作来重建表，例如修改表的存储引擎为当前的引擎。下面是一个针对InnoDB表的例子：

```sql
ALTER TABLE innodb_tb1 ENGINE=INNODB;
```

此外，也可以使用一些存储引擎相关的离线工具，例如myisamchk；或者将数据到处一份，然后再重新导入。不给过，如果损坏的是系统区域，或者是表的“行数据”区域，而不是索引，那么上面的办法就没有用了。在这种情况下，可以从备份中恢复表，或者尝试从损坏的数据文件中尽可能地恢复数据。

如果InnoDB引擎的表出现了损坏，那么一定是发生了严重的错误，需要立刻调查一下原因。InnoDB一般不会出现损坏。InnoDB的设计保证了它并不容易被损坏。如果发生损坏，一般要么是数据库的硬件问题例如内存或者磁盘问题（有可能），要么是由于数据库管理员的错误例如在MySQL外部操作了数据文件（有可能），亦或是InnoDB本身的缺陷（不太可能）。

### 5.5.2 更新索引统计信息

MySQL的查询优化器会通过两个API来了解存储引擎的索引值的分布信息，以决定如何使用索引。第一个API是records_in_range()，通过像存储引擎传入两个边界值获取这个范围大概有多少条记录。对于某些存储引擎，该接口返回精确值，例如MyISAM；但对于另一些存储引擎则是一个估算值，例如InnoDB。

第二个API是 info() ，该接口返回各种类型的数据，包括索引的基数（每个键值有多少条记录）。

如果存储引擎向优化器提供的扫描行数信息是不准确的数据，或者执行计划本身太复杂以致无法准确获取各个阶段匹配的行数，那么优化器会使用索引统计信息来估算扫描行数。MySQL优化器使用的是基于成本模型，而衡量成本的主要指标就是一个查询需要扫描多少行。如果表没有统计信息，或者统计信息不准确，优化器就很有可能做出错误的决定。可以通过运行ANALYZE TABLE来重新生成统计信息解决这个问题。

每种存储引擎实现索引统计信息的方式不同，所以需要进行ANALYZE TABLE的频率也因不同的引擎而不同，每次运行的成本也不同：

- MEmory引擎根本不存储索引统计信息。
- MyISAM将索引统计信息存储在磁盘中，ANALIZE TABLE需要进行一次全索引扫描来计算索引基数。在整个过程中需要缩表。
- 直到MySQL 5.5 版本，InnoDB也不在磁盘存储索引统计信息，而是通过随机的索引访问进行平局并将其存储在内存中。

InnoDB会在表首次打开，或者执行ANALYZE TABLE，亦或表的大小发生非常大的变化（大小变化超过十六分之一或者新插入了20亿行都会触发）代价时候计算索引的统计信息。

InnoDB在打开某些INFORMATION_SCHEMA表，或者使用SHOW TABLE STATUS 和SHOW INDEX，亦或在MYSQL客户端开启自动补全功能的时候都会出发索引统计信息的更新。如果服务器上有大量的数据，这可能就是个很严重的问题，尤其是当I/O比较慢的时候。客户端或者监控程序出发索引信息采样更新时可能会导致大量的锁，并给服务器带来很多额外压力，这会让用户因为启动时间漫长而沮丧。只要SHOW INDEX 查看索引统计信息，就一定会出发统计信息更新。可以关闭 innodb_stats_on_metadata 参数来避免上面提到的问题。

一旦关闭索引统计信息的自动更新，那么就需要周期性的使用ANALYZE TABLE来手动更新。否则，索引统计信息就会永远不变。如果数据分布发生大的变化，可能会出现一些很糟糕的执行计划。

### 5.5.3 减少索引和数据碎片

B-Tree 索引可能会碎片化，这会降低查询的效率。碎片化的索引可能会以很差或者无序的方式存储在磁盘上。

根据设计，B-Tree需要随机磁盘访问才能定位到叶子页，所以随机访问时不可避免的。然而，如果叶子页在物理分布上时顺序且紧密的，那么查询的性能就会更好。否则，对于范围查询、索引覆盖扫描等操作来说，速度可能会降低很多倍；对于索引覆盖扫描这一点更加明显。

表的数据存储也可能碎片化。然而，数据存储的碎片化比索引更加复杂。有三种类型的数据碎片。

- 行碎片（Row fragmentation）

  这种碎片指的时数据行被存储为多个地方的多个片段中。即使查询只从索引中访问一行记录，行碎片也会导致性能下降。

- 行间碎片（intra-row fragmentation）

  行间碎片是指逻辑上顺序的也，或者行在磁盘上不是顺序存储的。行间碎片对于诸如全表扫描和聚簇索引扫描之类的操作有很大的影响，因为这些操作原本能够从磁盘上顺序存储的数据中获益。

- 剩余空间碎片（Free space fragmentation）

  剩余空间碎片是指数据页中有大量的空余空间。这回导致服务器读取大量不需要的数据，从而造成浪费。

对于MyISAM表，这三类碎片化都可能发生。但InnoDB不会出现短小的行碎片；InnoDB会移动短小的行并重写到一个片段中。

可以通过执行OPTIMIZE TABLE 或者到处再导入的方式来重新整理数据。这对多数存储引擎都是有效的。对于一些存储引擎如MyISAM，可以通过排序算法重建索引的方式来消除碎片。老版本的InnoDB没有扫描消除碎片化的方法。不过最新版本InnoDB新增了“在线”添加和删除索引的功能，可以通过先删除，然后再重新创建索引的方式来消除索引的碎片化。



